<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chart Data Setting</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#18A0FB',
                        'primary-hover': '#0D86D8',
                        surface: '#F9F9F9',
                        border: '#E0E0E0',
                        'border-strong': '#BDBDBD',
                        danger: '#F24822',
                        text: '#333333',
                        'text-sub': '#888888'
                    },
                    fontSize: {
                        xxs: '10px',
                        xs: '11px',
                        sm: '12px'
                    },
                    boxShadow: {
                        'left-scroll': '-4px 0 12px -4px rgba(0, 0, 0, 0.1)',
                        'top-scroll': '0 -4px 12px -4px rgba(0, 0, 0, 0.1)'
                    }
                }
            }
        }
    </script>

    <style>
        body { font-family: 'Inter', sans-serif; }
        .step { display: none; opacity: 0; transform: translateY(2px); transition: all 0.3s ease-in-out; }
        .step.active { display: flex; opacity: 1; transform: translateY(0); }
        
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-thumb { background: #D1D5DB; border-radius: 4px; }
        ::-webkit-scrollbar-track { background: transparent; }

        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

        .tooltip-trigger:hover .tooltip-content { display: block; }

        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { 
            -webkit-appearance: inner-spin-button !important;
            opacity: 1 !important;
            cursor: pointer;
            display: block;
        }
        
        /* Row Header Hover Effects */
        .row-header:hover .del-row-btn { display: flex; }
    </style>
</head>
<body class="bg-white text-text flex flex-col h-screen box-border text-xs overflow-hidden">

    <header class="flex justify-between items-center h-12 shrink-0 px-3 border-b border-border bg-white z-50">
        <div class="flex items-center">
            <button id="back-btn" class="hidden text-text-sub hover:text-text bg-transparent border-0 cursor-pointer p-1 mr-1" title="Back">
                <svg class="w-4 h-4 fill-current" viewBox="0 0 24 24"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
            </button>
            
            <h1 class="text-sm font-semibold flex items-center gap-2 m-0">
                Chart Data 
                <div id="chart-type-wrapper" class="hidden flex items-center gap-1.5 bg-surface border border-border px-2 py-0.5 rounded text-text-sub">
                    <span id="chart-type-icon" class="flex items-center justify-center"></span>
                    <span id="chart-type-display" class="text-xxs font-medium uppercase tracking-wide">Bar</span>
                </div>
            </h1>
        </div>

        <div class="flex items-center gap-2">
            <button id="edit-mode-btn" class="hidden bg-transparent border-0 text-primary hover:text-primary-hover font-semibold text-xs cursor-pointer transition-colors min-w-[40px]">
                Save
            </button>
            <button id="main-cta" disabled class="bg-primary text-white px-3 py-1.5 rounded font-semibold text-xs cursor-pointer transition-colors hover:bg-primary-hover disabled:bg-surface disabled:text-text-sub disabled:border disabled:border-border disabled:cursor-not-allowed">
                Apply to Figma
            </button>
        </div>
    </header>

    <div id="step-1" class="step active flex-col gap-3 w-full p-3">
        <div class="border border-border rounded-md p-3 bg-white flex flex-col gap-2">
            <h2 class="text-xs font-semibold text-text-sub m-0 mb-1">Select Chart Type</h2>
            <div class="grid grid-cols-2 gap-3 mt-2">
                <button class="bg-white border border-border rounded-md py-6 px-3 flex flex-col items-center justify-center cursor-pointer transition-all hover:border-primary hover:bg-blue-50 hover:shadow-sm" onclick="selectType('bar')">
                    <svg class="w-8 h-8 fill-primary mb-2" viewBox="0 0 24 24"><path d="M4 19h4v-7H4v7zm6 0h4V9h-4v10zm6-14v14h4V5h-4zm2-4H2v22h22V1h-2z"/></svg>
                    <span class="font-semibold text-text">Bar Chart</span>
                </button>
                <button class="bg-white border border-border rounded-md py-6 px-3 flex flex-col items-center justify-center cursor-pointer transition-all hover:border-primary hover:bg-blue-50 hover:shadow-sm" onclick="selectType('line')">
                    <svg class="w-8 h-8 fill-primary mb-2" viewBox="0 0 24 24"><path d="M3.5 18.49l6-6.01 4 4L22 6.92l-1.41-1.41-7.09 7.97-4-4L2 16.99z"/></svg>
                    <span class="font-semibold text-text">Line Chart</span>
                </button>
                <button class="bg-white border border-border rounded-md py-6 px-3 flex flex-col items-center justify-center cursor-pointer transition-all hover:border-primary hover:bg-blue-50 hover:shadow-sm" onclick="selectType('stackedBar')">
                    <svg class="w-8 h-8 fill-primary mb-2" viewBox="0 0 24 24"><path d="M4 19h4v-4H4v4zm0-5h4v-3H4v3zm0-4h4V7H4v3zm6 9h4v-8h-4v8zm0-9h4V7h-4v3zm0-4h4V7h-4v3zm0-4h4V2h-4v4zm6 13h4v-6h-4v6zm0-7h4V7h-4v3zm0-4h4V2h-4v4z"/></svg>
                    <span class="font-semibold text-text">Stacked Bar</span>
                </button>
            </div>
        </div>
    </div>

    <div id="step-2" class="step flex-col w-full h-full overflow-hidden bg-surface">
        
        <div class="px-3 pt-3 pb-1 shrink-0 flex flex-col gap-1.5">
            <h2 class="text-[11px] font-bold text-text-sub uppercase tracking-wider ml-1">Graph Setting</h2>
            
            <div class="bg-white border border-border rounded-md p-3 flex flex-col shadow-sm gap-2">
                <div class="flex items-center gap-3">
                    <div class="flex flex-col gap-1 flex-1">
                        <label id="label-col-input" class="text-xxs font-medium text-text-sub">Graph Col</label>
                        <input type="number" id="setting-col-input" value="3" min="1" max="12" class="w-full px-2 py-1 border border-border rounded text-xs h-7 focus:border-primary focus:outline-none transition-colors">
                    </div>

                    <div class="flex flex-col gap-1 flex-1">
                        <label class="text-xxs font-medium text-text-sub">Cell Count</label>
                        <input type="number" id="setting-cell-input" value="4" min="1" max="10" class="w-full px-2 py-1 border border-border rounded text-xs h-7 focus:border-primary focus:outline-none transition-colors">
                    </div>

                    <div class="flex flex-col gap-1 flex-1">
                        <div id="container-mark-wrapper">
                            <label id="label-mark-position" class="text-xxs font-medium text-text-sub">Mark Count</label>
                            <div id="container-mark-normal" class="relative">
                                <select id="setting-mark-select" class="w-full px-2 py-1 border border-border rounded text-xs h-7 focus:border-primary focus:outline-none appearance-none bg-white cursor-pointer hover:border-text-sub transition-colors">
                                    <option value="1">1</option>
                                    <option value="2">2</option>
                                    <option value="3">3</option>
                                    <option value="4">4</option>
                                    <option value="5">5</option>
                                </select>
                                <div class="absolute right-2 top-1/2 -translate-y-1/2 pointer-events-none text-text-sub">
                                    <svg class="w-2.5 h-2.5 fill-current" viewBox="0 0 24 24"><path d="M7 10l5 5 5-5z"/></svg>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="flex items-center gap-3 border-t border-border pt-2 mt-1">
                    <div class="flex flex-col gap-1 flex-1">
                        <label class="text-xxs font-medium text-text-sub">Y Min</label>
                        <input type="number" id="setting-y-min" value="0" class="w-full px-2 py-1 border border-border rounded text-xs h-7 focus:border-primary focus:outline-none transition-colors">
                    </div>
                    <div class="flex flex-col gap-1 flex-1">
                        <label class="text-xxs font-medium text-text-sub">Y Max</label>
                        <input type="number" id="setting-y-max" value="100" class="w-full px-2 py-1 border border-border rounded text-xs h-7 focus:border-primary focus:outline-none transition-colors">
                    </div>
                    <div class="flex-1"></div> 
                </div>
            </div>
        </div>

        <div class="px-3 py-1 flex-1 flex flex-col gap-1.5 overflow-hidden pb-3">
            <h2 class="text-[11px] font-bold text-text-sub uppercase tracking-wider ml-1">Data Setting</h2>

            <div class="flex flex-col gap-2 h-full">
                <div class="bg-white border border-border rounded-md px-3 py-2 shadow-sm shrink-0 flex items-center justify-between">
                    <div class="flex items-center gap-2 overflow-hidden">
                         <span class="text-xs font-semibold text-text-sub shrink-0">CSV</span>
                         <div class="w-[1px] h-3 bg-border shrink-0"></div>
                         <span id="csv-status-text" class="text-xs text-text-sub truncate">csv를 업로드해주세요.</span>
                    </div>

                    <div class="flex items-center gap-2 shrink-0">
                        <button id="csv-delete-btn" class="hidden w-5 h-5 flex items-center justify-center rounded-full bg-gray-100 hover:bg-danger hover:text-white text-gray-500 transition-colors cursor-pointer" title="Remove CSV">
                            <svg class="w-3 h-3 fill-current" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 17.59 13.41 12z"/></svg>
                        </button>
                        <button id="csv-export-btn" class="text-text-sub hover:text-primary p-1 rounded transition-colors" title="Export CSV">
                             <svg class="w-3.5 h-3.5 fill-current" viewBox="0 0 24 24"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
                        </button>
                        <label for="csv-upload" class="bg-white border border-border rounded px-2 py-1 text-xxs font-medium text-text cursor-pointer hover:border-text-sub hover:bg-gray-50 transition-all whitespace-nowrap">
                            Upload
                        </label>
                        <input type="file" id="csv-upload" accept=".csv" class="hidden">
                    </div>
                </div>

                <div id="editor-card" class="bg-white border border-border rounded-md shadow-sm flex flex-col flex-1 overflow-hidden">
                    
                    <div class="px-3 border-b border-border flex justify-between items-center bg-white shrink-0 h-9">
                        <button id="reset-btn" class="text-text-sub hover:text-primary hover:bg-surface border border-transparent hover:border-border rounded px-1.5 py-0.5 text-xxs font-medium transition-all flex items-center gap-1 cursor-pointer">
                            <svg class="w-3 h-3 fill-current" viewBox="0 0 24 24"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
                            초기화
                        </button>

                        <div class="flex items-center gap-1.5">
                            <div id="mode-toggle-container" class="flex bg-surface rounded p-0.5 border border-border relative transition-colors duration-200">
                                <button id="mode-raw" class="px-2 py-0.5 text-xxs font-semibold rounded bg-white text-primary shadow-sm transition-all" onclick="setMode('raw')">Raw</button>
                                <button id="mode-percent" class="px-2 py-0.5 text-xxs font-semibold rounded text-text-sub hover:text-text transition-all" onclick="setMode('percent')">%</button>
                            </div>
                            <div class="relative tooltip-trigger cursor-help">
                                <svg class="w-3.5 h-3.5 fill-text-sub hover:fill-primary transition-colors" viewBox="0 0 24 24">
                                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/>
                                </svg>
                                <div id="main-tooltip" class="tooltip-content hidden absolute right-0 mt-2 w-52 bg-gray-800 text-white text-xxs rounded p-2 z-50 shadow-lg text-left leading-relaxed">
                                    <div id="tooltip-normal">
                                        <p class="mb-1"><strong class="text-primary-hover">Raw:</strong> 입력값의 제한이 없습니다.</p>
                                        <p><strong class="text-primary-hover">%:</strong> 0~100 사이의 비율값으로 보여집니다.</p>
                                        <p id="tooltip-stacked-hint" class="hidden text-[10px] text-gray-400 mt-1 pt-1 border-t border-gray-600">* Stacked Bar: Row 1은 All(Total) 목표값입니다.</p>
                                    </div>
                                    <div id="tooltip-warning" class="hidden text-danger font-medium">
                                        ⚠️ % 모드에서는 0~100 사이의 값만 입력할 수 있습니다.
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div id="grid-container-wrapper" class="flex flex-1 relative overflow-hidden bg-white">
                        <div class="flex flex-col border-t border-border z-10 shadow-left-scroll bg-surface shrink min-w-[72px]">
                            <div class="h-6 border-r border-b border-border-strong bg-surface shrink-0"></div>
                            <div id="row-header-container" class="overflow-hidden flex-col no-scrollbar pb-10"></div>
                        </div>
                        <div id="grid-scroll-area" class="flex-1 overflow-auto relative scroll-smooth">
                            <div id="data-grid" class="grid gap-0 border-t border-l border-border w-fit"></div>
                        </div>
                        <div class="w-8 shrink-0 border-l border-b border-t border-border bg-white flex flex-col z-20 shadow-left-scroll">
                            <div class="h-6 border-b border-border-strong bg-surface flex items-center justify-center shrink-0">
                                <svg class="w-3 h-3 fill-text-sub" viewBox="0 0 0 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
                            </div>
                            <button id="add-col-fixed-btn" class="flex-1 w-full text-primary hover:bg-surface flex items-center justify-center cursor-pointer font-medium text-lg focus:outline-none active:bg-blue-50 transition-colors" title="Add Column / Group">+</button>
                        </div>
                    </div>

                    <div class="h-7 flex shrink-0 border-t border-border bg-white z-20 shadow-top-scroll">
                        <button id="add-row-fixed-btn" class="flex-1 text-primary hover:bg-surface flex items-center justify-center cursor-pointer text-xs font-medium focus:outline-none active:bg-blue-50 transition-colors">+ Add Row</button>
                        <div class="w-8 shrink-0 border-l border-border bg-surface"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="error-toast" class="hidden fixed bottom-16 left-1/2 -translate-x-1/2 bg-danger text-white text-xs px-4 py-2.5 rounded-md shadow-lg z-50 flex items-center gap-2 transition-all duration-300 opacity-0 translate-y-2 pointer-events-none">
        <svg class="w-4 h-4 fill-white shrink-0" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/></svg>
        <span>% 모드는 0~100 사이의 값이어야 합니다.</span>
    </div>

    <div id="restore-toast" class="hidden fixed bottom-14 left-1/2 -translate-x-1/2 bg-gray-800 text-white text-xs px-4 py-3 rounded-md shadow-lg z-50 flex items-center gap-4 transition-all duration-300 opacity-0 translate-y-2">
        <span>저장된 데이터를 불러올까요?</span>
        <div class="flex items-center gap-3">
            <button id="toast-yes-btn" class="font-bold text-primary hover:text-blue-300 cursor-pointer">예</button>
            <button id="toast-close-btn" class="text-gray-400 hover:text-white cursor-pointer">✕</button>
        </div>
    </div>

    <script>
        const MAX_SIZE = 25;
        const state = {
            rows: 3,        
            cols: 3, 
            cellCount: 4,
            groupStructure: [2, 2, 2], 
            data: [], 
            mode: 'edit', chartType: 'bar', 
            dataMode: 'raw', 
            currentStep: 1,
            csvFileName: null,
            uiMode: 'create',
            cachedRawData: null, 
            conversionMax: 100 
        };
        
        const CHART_ICONS = {
            bar: `<svg class="w-3 h-3 fill-current" viewBox="0 0 24 24"><path d="M4 19h4v-7H4v7zm6 0h4V9h-4v10zm6-14v14h4V5h-4zm2-4H2v22h22V1h-2z"/></svg>`,
            line: `<svg class="w-3 h-3 fill-current" viewBox="0 0 24 24"><path d="M3.5 18.49l6-6.01 4 4L22 6.92l-1.41-1.41-7.09 7.97-4-4L2 16.99z"/></svg>`,
            stackedBar: `<svg class="w-3 h-3 fill-current" viewBox="0 0 24 24"><path d="M4 19h4v-4H4v4zm0-5h4v-3H4v3zm0-4h4V7H4v3zm6 9h4v-8h-4v8zm0-9h4V7h-4v3zm0-4h4V7h-4v3zm0-4h4V2h-4v4zm6 13h4v-6h-4v6zm0-7h4V7h-4v3zm0-4h4V2h-4v4z"/></svg>`
        };

        const ui = {
            step1: document.getElementById('step-1'),
            step2: document.getElementById('step-2'),
            backBtn: document.getElementById('back-btn'),
            mainCta: document.getElementById('main-cta'),
            editModeBtn: document.getElementById('edit-mode-btn'), 
            
            chartTypeWrapper: document.getElementById('chart-type-wrapper'),
            chartTypeIcon: document.getElementById('chart-type-icon'),
            chartTypeDisplay: document.getElementById('chart-type-display'),
            
            settingColInput: document.getElementById('setting-col-input'),
            settingCellInput: document.getElementById('setting-cell-input'),
            settingMarkSelect: document.getElementById('setting-mark-select'),
            
            containerMarkWrapper: document.getElementById('container-mark-wrapper'),
            containerMarkNormal: document.getElementById('container-mark-normal'),
            
            labelColInput: document.getElementById('label-col-input'),
            labelMarkPosition: document.getElementById('label-mark-position'),

            settingYMin: document.getElementById('setting-y-min'),
            settingYMax: document.getElementById('setting-y-max'),
            
            csvInput: document.getElementById('csv-upload'),
            csvStatusText: document.getElementById('csv-status-text'),
            csvDeleteBtn: document.getElementById('csv-delete-btn'), 
            
            gridScrollArea: document.getElementById('grid-scroll-area'),
            gridContainer: document.getElementById('data-grid'),
            rowHeaderContainer: document.getElementById('row-header-container'), 
            
            addColFixedBtn: document.getElementById('add-col-fixed-btn'),
            addRowFixedBtn: document.getElementById('add-row-fixed-btn'),
            resetBtn: document.getElementById('reset-btn'),

            modeToggleContainer: document.getElementById('mode-toggle-container'),
            modeRawBtn: document.getElementById('mode-raw'),
            modePercentBtn: document.getElementById('mode-percent'),
            
            tooltipNormal: document.getElementById('tooltip-normal'),
            tooltipWarning: document.getElementById('tooltip-warning'),
            mainTooltip: document.getElementById('main-tooltip'),
            tooltipStackedHint: document.getElementById('tooltip-stacked-hint'),

            csvExportBtn: document.getElementById('csv-export-btn'),
            toast: document.getElementById('restore-toast'),
            toastYesBtn: document.getElementById('toast-yes-btn'),
            toastCloseBtn: document.getElementById('toast-close-btn'),
            errorToast: document.getElementById('error-toast') 
        };

        ui.gridScrollArea.addEventListener('scroll', () => {
            if(ui.rowHeaderContainer) {
                ui.rowHeaderContainer.scrollTop = ui.gridScrollArea.scrollTop;
            }
        });

        function getTotalStackedCols() {
            return state.groupStructure.reduce((a, b) => a + b, 0);
        }

        function checkDataRange() {
            if(state.dataMode === 'raw') return true; 
            const totalVisualRows = state.data.length;
            const totalCols = state.data.length > 0 ? state.data[0].length : 0;
            for (let i = 0; i < totalVisualRows; i++) {
                for (let j = 0; j < totalCols; j++) {
                    const val = state.data[i][j];
                    if (val && val.trim() !== "") {
                        const num = Number(val);
                        if (!isNaN(num) && (num < 0 || num > 100)) return false; 
                    }
                }
            }
            return true;
        }

        function clearRangeErrors() {
            ui.gridContainer.querySelectorAll('input').forEach(input => {
                const wrapper = input.parentElement;
                wrapper.classList.remove('bg-red-50', 'bg-red-200'); // Remove all error backgrounds
                const row = parseInt(input.dataset.row);
                
                // Stacked Bar Row 0(All) 배경 처리
                if (state.chartType === 'stackedBar' && row === 0) {
                    wrapper.classList.add('bg-blue-50');
                } else {
                    wrapper.classList.add((row % 2 === 1) ? 'bg-surface' : 'bg-white');
                }
                
                input.classList.remove('text-danger', 'font-medium', 'font-bold');
            });
        }

        function updateModeButtonState() {
            if(state.dataMode === 'percent') {
                 ui.modePercentBtn.className = 'px-2 py-0.5 text-xxs font-semibold rounded bg-white text-primary shadow-sm transition-all';
                 ui.modeRawBtn.className = 'px-2 py-0.5 text-xxs font-semibold rounded text-text-sub hover:text-text transition-all';
            } else {
                 ui.modePercentBtn.className = 'px-2 py-0.5 text-xxs font-semibold rounded text-text-sub hover:text-text transition-all';
                 ui.modeRawBtn.className = 'px-2 py-0.5 text-xxs font-semibold rounded bg-white text-primary shadow-sm transition-all';
            }
        }

        window.setMode = function(targetMode) {
            if (state.dataMode === targetMode) return;
            if (state.dataMode === 'raw' && targetMode === 'percent') {
                state.cachedRawData = JSON.parse(JSON.stringify(state.data));
                let maxVal = 0;
                state.data.forEach(row => { row.forEach(val => { const num = Number(val); if (!isNaN(num) && num > maxVal) maxVal = num; }); });
                if (maxVal === 0) maxVal = 100; state.conversionMax = maxVal;
                state.data = state.data.map(row => row.map(val => { if(val==="")return""; const num=Number(val); if(isNaN(num))return val; return String(Math.round((num/maxVal)*100*10)/10); }));
                state.dataMode = 'percent';
            } else if (state.dataMode === 'percent' && targetMode === 'raw') {
                if (state.cachedRawData) { state.data = state.cachedRawData; state.cachedRawData = null; }
                else { state.data = state.data.map(row => row.map(val => { if(val==="")return""; const num=Number(val); if(isNaN(num))return val; return String(Math.round((num/100)*state.conversionMax)); })); }
                state.dataMode = 'raw';
            }
            const isValid = checkDataRange();
            if(!isValid && state.dataMode === 'percent') { ui.tooltipNormal.classList.add('hidden'); ui.tooltipWarning.classList.remove('hidden'); }
            else { ui.tooltipNormal.classList.remove('hidden'); ui.tooltipWarning.classList.add('hidden'); clearRangeErrors(); }
            updateModeButtonState(); renderGrid();
        };

        function downloadCsv() { 
            let csvContent = "data:text/csv;charset=utf-8,";
            state.data.forEach(rowArray => {
                let row = rowArray.join(",");
                csvContent += row + "\r\n";
            });
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "chart_data.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function showToast() { ui.toast.classList.remove('hidden'); setTimeout(() => { ui.toast.classList.remove('opacity-0', 'translate-y-2'); }, 50); }
        function hideToast() { ui.toast.classList.add('opacity-0', 'translate-y-2'); setTimeout(() => { ui.toast.classList.add('hidden'); }, 300); }
        ui.toastCloseBtn.addEventListener('click', hideToast);
        ui.toastYesBtn.addEventListener('click', () => { hideToast(); });
        function updateCsvUi() { 
            const isUploaded = !!state.csvFileName;
            ui.csvStatusText.textContent = isUploaded ? state.csvFileName : "csv를 업로드해주세요.";
            ui.csvStatusText.className = isUploaded ? 'text-xs text-primary font-semibold truncate' : 'text-xs text-text-sub truncate';
            isUploaded ? ui.csvDeleteBtn.classList.remove('hidden') : ui.csvDeleteBtn.classList.add('hidden');
        }
        function removeCsv() { state.csvFileName = null; ui.csvInput.value = ''; updateCsvUi(); }

        function updateHeaderIcon() {
            let displayType = 'Bar';
            if(state.chartType === 'line') displayType = 'Line';
            else if(state.chartType === 'stackedBar') displayType = 'Stacked';
            ui.chartTypeDisplay.textContent = displayType;
            ui.chartTypeIcon.innerHTML = CHART_ICONS[state.chartType] || CHART_ICONS['bar'];
            
            // Tooltip toggle
            if(state.chartType === 'stackedBar') ui.tooltipStackedHint.classList.remove('hidden');
            else ui.tooltipStackedHint.classList.add('hidden');
        }

        function goToStep(stepNum) {
            state.currentStep = stepNum;
            document.querySelectorAll('.step').forEach(el => el.classList.remove('active'));
            if (stepNum === 1) {
                ui.step1.classList.add('active');
                ui.backBtn.classList.add('hidden');
                ui.chartTypeWrapper.classList.add('hidden'); 
                ui.mainCta.style.display = 'none';
                ui.editModeBtn.classList.add('hidden'); 
                removeCsv();
                parent.postMessage({ pluginMessage: { type: 'resize', width: 300, height: 400 } }, '*');
                state.uiMode = 'create';
            } else {
                ui.step2.classList.add('active');
                ui.backBtn.classList.remove('hidden');
                ui.chartTypeWrapper.classList.remove('hidden'); 
                
                const targetHeight = state.chartType === 'stackedBar' ? 680 : 620;
                parent.postMessage({ pluginMessage: { type: 'resize', width: 600, height: targetHeight } }, '*'); 

                updateHeaderIcon();
                ui.mainCta.style.display = 'block';
                ui.mainCta.textContent = state.uiMode === 'create' ? "Generate to Figma" : "Apply to Figma";
                ui.editModeBtn.classList.remove('hidden');
                
                try {
                    updateSettingInputs(); 
                    renderGrid();
                    checkCtaValidation();
                    updateModeButtonState(); 
                } catch (e) { console.error("Render Error:", e); }
            }
        }

        window.selectType = function(type) {
            state.chartType = type;
            resetData(); 
            goToStep(2);
        };

        ui.backBtn.addEventListener('click', () => { goToStep(1); hideToast(); });

        function initData(rows, cols) {
            const newData = [];
            for (let i = 0; i < rows; i++) {
                const row = new Array(cols).fill("");
                newData.push(row);
            }
            return newData;
        }

        window.onmessage = (event) => {
            const msg = event.data.pluginMessage;
            if (!msg) return;

            if (msg.type === 'init') {
                state.uiMode = msg.uiMode || 'create';
                
                if (msg.chartType) {
                    state.chartType = msg.chartType;
                    
                    let targetData = null;
                    let targetMarkNum = null;

                    // Priority: Saved Data > Inferred Data
                    if (msg.savedValues) {
                        targetData = msg.savedValues;
                        targetMarkNum = msg.savedMarkNum;
                    } else if (msg.inferredValues) {
                        targetData = msg.inferredValues;
                        targetMarkNum = msg.inferredMarkNum;
                    }

                    if (targetData) {
                        // Apply Data
                        state.data = targetData.map(row => row.map(v => String(v)));
                        
                        if (msg.chartType === 'stackedBar') {
                            if (targetMarkNum && Array.isArray(targetMarkNum)) {
                                state.groupStructure = targetMarkNum;
                                state.cols = state.groupStructure.length;
                            } else {
                                state.cols = 1; 
                                state.groupStructure = [state.data[0].length];
                            }
                            
                            // [SMART LOAD LOGIC]
                            // 저장된 데이터가 All 행을 포함하고 있는지 확인 (Visual Rows vs Data Rows)
                            // 1. Inferred(Visual) Data가 있다면 Row 수는 실제 막대 개수
                            // 2. 만약 Saved Data의 Row 수가 Visual Row 수와 같다면 -> All 행이 없는 구버전 데이터 -> unshift 필요
                            // 3. 만약 Saved Data가 더 많다면 -> All 행이 있는 신버전 데이터 -> unshift 불필요
                            
                            let shouldAddAllRow = false;
                            
                            if (targetData === msg.inferredValues) {
                                // 그래프에서 읽어온 데이터는 무조건 All 행 없음 (Visual only)
                                shouldAddAllRow = true;
                            } else if (targetData === msg.savedValues) {
                                // 저장된 데이터 로드 시
                                const visualRowCount = msg.inferredValues ? msg.inferredValues.length : 0;
                                // 저장된 데이터 행이 시각적 행보다 같거나 적으면 'All' 행이 없는 것으로 간주
                                if (state.data.length <= visualRowCount) {
                                    shouldAddAllRow = true;
                                }
                            }

                            if (shouldAddAllRow) {
                                const colsCount = state.data.length > 0 ? state.data[0].length : state.cols;
                                state.data.unshift(new Array(colsCount).fill(""));
                            }
                            
                            state.rows = state.data.length; 

                        } else {
                            state.rows = state.data.length;
                            state.cols = state.data[0].length;
                            if (msg.chartType === 'line') state.cols = Math.max(1, state.cols - 1);
                        }
                    } else {
                        // Default Initialization
                        if (msg.chartType === 'stackedBar') {
                            state.groupStructure = [2, 2, 2];
                            state.data = initData(4, 6); // Row 0(All) + 3 Stacks = 4 rows
                            state.rows = 4;
                            state.cols = 3;
                        } else {
                            state.rows = 3; 
                            state.cols = 3;
                            state.data = initData(3, 3);
                        }
                    }
                    
                    updateSettingInputs();
                    updateModeButtonState(); 
                    goToStep(2); 
                } else {
                    state.uiMode = 'create';
                    goToStep(1); 
                }
            }
        };

        // ==========================================
        // VALIDATION LOGIC FOR STACKED BAR
        // ==========================================
        function validateStackedData() {
            if (state.chartType !== 'stackedBar') return;
            if (state.data.length < 2) return; 

            const totalCols = state.data[0].length;

            for (let c = 0; c < totalCols; c++) {
                // 1. Get All Value (Row 0)
                const allValStr = state.data[0][c];
                const allVal = Number(allValStr);
                
                // If All is empty, skip strict validation but clear errors
                if (allValStr === "" || isNaN(allVal)) {
                     for (let r = 0; r < state.rows; r++) {
                         const cellInput = document.querySelector(`input[data-row="${r}"][data-col="${c}"]`);
                         if(cellInput) {
                             const wrapper = cellInput.parentElement;
                             if (wrapper.classList.contains('bg-red-200')) {
                                 wrapper.classList.remove('bg-red-200');
                                 cellInput.classList.remove('text-danger', 'font-bold');
                                 if (r === 0) wrapper.classList.add('bg-blue-50');
                                 else wrapper.classList.add((r % 2 === 1) ? 'bg-surface' : 'bg-white');
                             }
                         }
                     }
                    continue;
                }

                let stackSum = 0;
                
                // 2. Iterate Stacks (Row 1 ~ End)
                for (let r = 1; r < state.rows; r++) {
                    const stackValStr = state.data[r][c];
                    const stackVal = Number(stackValStr);
                    const cellInput = document.querySelector(`input[data-row="${r}"][data-col="${c}"]`);
                    
                    if (cellInput) {
                        const wrapper = cellInput.parentElement;
                        let isError = false;

                        if (stackValStr !== "" && !isNaN(stackVal)) {
                            stackSum += stackVal;
                            
                            // Condition B: Single Stack > All
                            if (stackVal > allVal) {
                                isError = true;
                                wrapper.classList.remove('bg-white', 'bg-surface');
                                wrapper.classList.add('bg-red-200');
                                cellInput.classList.add('text-danger', 'font-bold');
                            }
                        }

                        if (!isError && wrapper.classList.contains('bg-red-200')) {
                             wrapper.classList.remove('bg-red-200');
                             cellInput.classList.remove('text-danger', 'font-bold');
                             wrapper.classList.add((r % 2 === 1) ? 'bg-surface' : 'bg-white');
                        }
                    }
                }

                // 3. Condition A: Sum of Stacks > All
                const allInput = document.querySelector(`input[data-row="0"][data-col="${c}"]`);
                if (allInput) {
                    const wrapper = allInput.parentElement;
                    if (stackSum > allVal) {
                        wrapper.classList.remove('bg-blue-50');
                        wrapper.classList.add('bg-red-200');
                        allInput.classList.add('text-danger', 'font-bold');
                    } else {
                        if (wrapper.classList.contains('bg-red-200')) {
                            wrapper.classList.remove('bg-red-200');
                            wrapper.classList.add('bg-blue-50');
                            allInput.classList.remove('text-danger', 'font-bold');
                        }
                    }
                }
            }
        }

        // ==========================================
        // MAIN GRID RENDERER
        // ==========================================
        function renderGrid() {
            ui.gridContainer.innerHTML = ''; 
            ui.rowHeaderContainer.innerHTML = ''; 
            
            if (!state.data || state.data.length === 0) return;
            let gridCols = state.data[0].length;
            
            ui.gridContainer.style.gridTemplateColumns = `repeat(${gridCols}, minmax(60px, 1fr))`;

            // ----------------------------------------------------
            // [HEADER AREA]
            // ----------------------------------------------------
            if (state.chartType === 'stackedBar') {
                // [Level 1] Super Header (Groups)
                for (let g = 0; g < state.groupStructure.length; g++) { 
                    const groupHeader = document.createElement('div');
                    const spanCount = state.groupStructure[g];
                    groupHeader.style.gridColumn = `span ${spanCount}`;
                    
                    groupHeader.className = 'sticky top-0 z-30 bg-gray-100 border-r border-b border-border-strong flex items-center justify-center h-6 text-xxs font-bold text-text group relative';
                    groupHeader.innerHTML = `<span>Group ${g + 1}</span>`;

                    if (state.mode === 'edit') {
                        const addBarBtn = document.createElement('button');
                        addBarBtn.className = 'absolute left-1 top-1/2 -translate-y-1/2 w-4 h-4 hidden group-hover:flex items-center justify-center bg-transparent border-0 cursor-pointer text-primary hover:text-primary-hover';
                        addBarBtn.innerHTML = `<svg class="w-3 h-3 fill-current" viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>`;
                        addBarBtn.title = "Add Bar to Group";
                        addBarBtn.onclick = (e) => { e.stopPropagation(); addBarToGroup(g); };
                        groupHeader.appendChild(addBarBtn);

                        const delBtn = document.createElement('button');
                        delBtn.className = 'absolute right-1 top-1/2 -translate-y-1/2 w-4 h-4 hidden group-hover:flex items-center justify-center bg-transparent border-0 cursor-pointer text-text-sub hover:text-danger';
                        delBtn.innerHTML = `<svg class="w-3 h-3 fill-current" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>`;
                        delBtn.onclick = (e) => { e.stopPropagation(); deleteColumn(g); };
                        groupHeader.appendChild(delBtn);
                    }
                    ui.gridContainer.appendChild(groupHeader);
                }

                // [Level 2] Sub Header (Bars)
                state.groupStructure.forEach((count, gIdx) => {
                    for (let b = 0; b < count; b++) {
                        const subHeader = document.createElement('div');
                        subHeader.className = 'sticky top-6 z-20 bg-surface border-r border-b border-border-strong flex items-center justify-center h-6 text-[9px] font-medium text-text-sub group relative';
                        subHeader.textContent = `Bar ${b + 1}`;
                        
                        if (state.mode === 'edit') {
                            const delSubBtn = document.createElement('button');
                            delSubBtn.className = 'absolute right-0 top-1/2 -translate-y-1/2 w-3 h-3 hidden group-hover:flex items-center justify-center bg-transparent border-0 cursor-pointer text-text-sub hover:text-danger';
                            delSubBtn.innerHTML = `<svg class="w-2 h-2 fill-current" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>`;
                            const currentG = gIdx; 
                            const currentB = b;
                            delSubBtn.onclick = (e) => { e.stopPropagation(); removeBarFromGroup(currentG, currentB); };
                            subHeader.appendChild(delSubBtn);
                        }
                        ui.gridContainer.appendChild(subHeader);
                    }
                });

            } else {
                // CASE B: Normal Charts
                for (let j = 0; j < gridCols; j++) {
                    const headerCell = document.createElement('div');
                    headerCell.className = 'sticky top-0 z-20 bg-surface border-r border-b border-border-strong flex items-center justify-center h-6 text-xxs font-semibold text-text-sub group relative';
                    
                    let colLabel = `${j + 1}`;
                    if (state.chartType === 'line') colLabel = `P ${j + 1}`;
                    
                    headerCell.innerHTML = `<span>${colLabel}</span>`;
                    if (state.mode === 'edit') {
                        const delBtn = document.createElement('button');
                        delBtn.className = 'absolute right-0.5 top-1/2 -translate-y-1/2 w-4 h-4 hidden group-hover:flex items-center justify-center bg-transparent border-0 cursor-pointer text-text-sub hover:text-danger';
                        delBtn.innerHTML = `<svg class="w-3 h-3 fill-current" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>`;
                        delBtn.onclick = () => deleteColumn(j);
                        headerCell.appendChild(delBtn);
                    }
                    ui.gridContainer.appendChild(headerCell);
                }
            }

            // ----------------------------------------------------
            // [BODY AREA] Rows
            // ----------------------------------------------------
            state.data.forEach((row, rowIndex) => {
                const isStackedAll = (state.chartType === 'stackedBar' && rowIndex === 0);
                
                const isZebra = (rowIndex % 2 === 1);
                let bgClass = isZebra ? 'bg-surface' : 'bg-white';
                if (isStackedAll) bgClass = 'bg-blue-50'; 

                const rowHeader = document.createElement('div');
                rowHeader.className = `row-header group relative w-full h-6 px-2 border-b border-r border-border-strong text-xxs font-semibold text-text-sub flex items-center justify-between truncate ${bgClass}`;
                
                let rowLabelText = "";
                if (state.chartType === 'line') rowLabelText = `Line ${rowIndex + 1}`;
                else if (state.chartType === 'stackedBar') {
                    if (rowIndex === 0) rowLabelText = `All (Total)`;
                    else rowLabelText = `Stack ${rowIndex}`;
                } else {
                    rowLabelText = `Bar ${rowIndex + 1}`;
                }
                
                const textSpan = document.createElement('span');
                textSpan.textContent = rowLabelText;
                textSpan.className = "truncate"; 
                if (isStackedAll) textSpan.classList.add('text-primary-hover', 'font-bold');
                rowHeader.appendChild(textSpan);
                
                if (state.mode === 'edit' && !isStackedAll) {
                     const delRowBtn = document.createElement('button');
                     delRowBtn.innerHTML = `<svg class="w-3 h-3 fill-current" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 17.59 17.59 13.41 12 19 6.41z"/></svg>`;
                     delRowBtn.className = 'del-row-btn w-4 h-4 hidden items-center justify-center bg-transparent border-0 cursor-pointer text-text-sub hover:text-danger shrink-0';
                     delRowBtn.onclick = (e) => { e.stopPropagation(); deleteRow(rowIndex); };
                     rowHeader.appendChild(delRowBtn);
                }
                ui.rowHeaderContainer.appendChild(rowHeader);

                // Cells
                row.forEach((cellValue, colIndex) => {
                    const cellWrapper = document.createElement('div');
                    cellWrapper.className = `flex items-center w-full h-6 border-r border-b border-border-strong ${bgClass}`;
                    const input = document.createElement('input');
                    input.type = 'text'; input.value = cellValue; input.dataset.row = rowIndex; input.dataset.col = colIndex;
                    
                    let isError = false; 
                    if (state.dataMode === 'percent' && cellValue !== "") { 
                        const num = Number(cellValue); 
                        if (!isNaN(num) && (num < 0 || num > 100)) isError = true; 
                    }
                    let classes = `flex-1 w-full h-full px-2 text-xs text-right focus:outline-none bg-transparent min-w-0`;
                    if (isError) { cellWrapper.classList.remove('bg-white', 'bg-surface', 'bg-blue-50'); cellWrapper.classList.add('bg-red-50'); classes += ' text-danger font-medium'; }
                    if (state.mode === 'read') classes += ' text-gray-400 cursor-not-allowed';
                    
                    if (isStackedAll) classes += ' font-bold text-primary';

                    input.className = classes;
                    input.addEventListener('input', (e) => {
                        state.data[rowIndex][colIndex] = e.target.value;
                        updateModeButtonState(); 
                        
                        if (state.chartType === 'stackedBar') {
                            validateStackedData();
                        }

                        const val = e.target.value; const num = Number(val);
                        const isErr = (state.dataMode === 'percent' && val!=="" && (!isNaN(num) && (num<0 || num>100)));
                        if(isErr && !cellWrapper.classList.contains('bg-red-200')) { 
                            cellWrapper.classList.remove(bgClass); cellWrapper.classList.add('bg-red-50'); e.target.classList.add('text-danger', 'font-medium'); 
                        } else if (!cellWrapper.classList.contains('bg-red-200')) { 
                            cellWrapper.classList.remove('bg-red-50'); cellWrapper.classList.add(bgClass); e.target.classList.remove('text-danger', 'font-medium'); 
                        }
                        
                        checkCtaValidation();
                    });
                    cellWrapper.appendChild(input);
                    if (state.dataMode === 'percent') {
                        const unitSpan = document.createElement('span'); unitSpan.className = 'shrink-0 pr-2 pl-0.5 text-[10px] text-text-sub pointer-events-none'; unitSpan.innerText = '%'; cellWrapper.appendChild(unitSpan);
                    }
                    ui.gridContainer.appendChild(cellWrapper);
                });
            });

            if (state.chartType === 'stackedBar') {
                ui.rowHeaderContainer.style.marginTop = '24px'; 
                validateStackedData();
            } else {
                ui.rowHeaderContainer.style.marginTop = '0px'; 
            }
            checkCtaValidation();
        }

        function addBarToGroup(groupIndex) {
            if (state.groupStructure[groupIndex] >= 10) return;
            let insertAt = 0;
            for (let i = 0; i < groupIndex; i++) {
                insertAt += state.groupStructure[i];
            }
            insertAt += state.groupStructure[groupIndex]; 

            state.data.forEach(row => { row.splice(insertAt, 0, ""); });
            state.groupStructure[groupIndex]++;
            renderGrid();
        }

        function removeBarFromGroup(groupIndex, barIndex) {
            if (state.groupStructure[groupIndex] <= 1) {
                alert("Minimum 1 bar per group."); return; 
            }
            let deleteAt = 0;
            for (let i = 0; i < groupIndex; i++) {
                deleteAt += state.groupStructure[i];
            }
            deleteAt += barIndex;
            state.data.forEach(row => { row.splice(deleteAt, 1); });
            state.groupStructure[groupIndex]--;
            renderGrid();
        }

        function handleDimensionInput() {
            let inputCell = parseInt(ui.settingCellInput.value);
            if (isNaN(inputCell) || inputCell < 1) inputCell = 1;
            if (inputCell > 10) inputCell = 10; 
            state.cellCount = inputCell;

            let inputCols = parseInt(ui.settingColInput.value);
            if (inputCols < 1) inputCols = 1; if (inputCols > MAX_SIZE) inputCols = MAX_SIZE;
            
            if (state.chartType === 'stackedBar') {
                const currentGroupCount = state.cols;
                if (inputCols > currentGroupCount) {
                    const addedCount = inputCols - currentGroupCount;
                    for(let k=0; k<addedCount; k++) {
                        state.groupStructure.push(2); 
                        state.data.forEach(row => { row.push("", ""); });
                    }
                } else if (inputCols < currentGroupCount) {
                    const removedCount = currentGroupCount - inputCols;
                    for(let k=0; k<removedCount; k++) {
                        const barsToRemove = state.groupStructure.pop();
                        state.data.forEach(row => { row.splice(-barsToRemove, barsToRemove); });
                    }
                }
                state.cols = inputCols;
                renderGrid(); 
            } else {
                let inputRows = parseInt(ui.settingMarkSelect.value);
                state.cols = inputCols;
                let targetDataCols = inputCols;
                if (state.chartType === 'line') {
                    targetDataCols = inputCols + 1;
                }
                updateGridSize(inputRows, targetDataCols);
            }
            updateSettingInputs();
        }

        function updateGridSize(newRows, newCols) {
            const currentRows = state.data.length;
            const currentCols = currentRows > 0 ? state.data[0].length : 0;
            const newData = [];
            for (let i = 0; i < newRows; i++) {
                const newRow = [];
                for (let j = 0; j < newCols; j++) {
                    if (i < currentRows && j < currentCols) {
                        newRow.push(state.data[i][j]);
                    } else {
                        newRow.push("");
                    }
                }
                newData.push(newRow);
            }
            state.data = newData;
            state.rows = newRows;
            renderGrid();
        }

        function addColumn() {
            if (state.cols >= MAX_SIZE) return;

            if(state.chartType === 'stackedBar') {
                state.cols++;
                state.groupStructure.push(2); 
                state.data.forEach(row => { row.push("", ""); });
                updateSettingInputs(); 
                renderGrid();
            } else {
                state.cols++;
                updateGridSize(state.rows, state.cols);
                updateSettingInputs();
            }
            setTimeout(() => { ui.gridScrollArea.scrollTo({ left: ui.gridScrollArea.scrollWidth, behavior: 'smooth' }); }, 50);
        }
        
        function addRow() {
            if (state.rows >= MAX_SIZE) return;
            state.rows++;
            
            const currentCols = state.data.length > 0 ? state.data[0].length : 
                                (state.chartType === 'stackedBar' ? getTotalStackedCols() : state.cols);
            state.data.push(new Array(currentCols).fill(""));

            if(state.chartType !== 'stackedBar') ui.settingMarkSelect.value = state.rows;

            updateSettingInputs(); 
            renderGrid();
            
            setTimeout(() => { ui.gridScrollArea.scrollTo({ top: ui.gridScrollArea.scrollHeight, behavior: 'smooth' }); }, 50);
        }

        function deleteColumn(colIndex) {
            if (state.cols <= 1) return;
            
            if (state.chartType === 'stackedBar') {
                const barsToRemove = state.groupStructure[colIndex];
                let startAt = 0;
                for(let i=0; i<colIndex; i++) startAt += state.groupStructure[i];
                state.data.forEach(row => row.splice(startAt, barsToRemove));
                state.groupStructure.splice(colIndex, 1);
                state.cols--;
            } else {
                state.data.forEach(row => row.splice(colIndex, 1));
                state.cols--;
            }
            updateSettingInputs(); renderGrid();
        }

        function deleteRow(rowIndex) {
            if (state.chartType === 'stackedBar' && rowIndex === 0) return;
            
            if (state.rows <= 1) return;
            state.data.splice(rowIndex, 1);
            state.rows--;
            updateSettingInputs(); renderGrid();
        }
        
        function resetData() {
            state.rows = 3;
            state.cols = 3; 
            
            if (state.chartType === 'stackedBar') {
                state.groupStructure = [2, 2, 2];
                state.data = initData(4, 6); // Row 0(All) + 3 Stacks = 4 rows
                state.rows = 4;
                state.cols = 3; 
            } else if (state.chartType === 'line') {
                state.data = initData(3, 4);
            } else {
                state.data = initData(3, 3);
            }
            state.dataMode = 'raw'; 
            updateSettingInputs();
            renderGrid();
        }
        
        function updateSettingInputs() {
            ui.settingCellInput.value = state.cellCount;
            
            if (state.chartType === 'stackedBar') {
                 ui.labelColInput.textContent = "Group Count"; 
                 ui.settingColInput.value = state.cols; 
                 ui.containerMarkWrapper.classList.add('hidden');
            } else {
                 ui.labelColInput.textContent = "Graph Col";
                 ui.settingColInput.value = state.cols;
                 ui.containerMarkWrapper.classList.remove('hidden');
                 
                 if (state.rows > 5) {
                    if (!ui.settingMarkSelect.querySelector(`option[value="${state.rows}"]`)) {
                        const opt = document.createElement('option');
                        opt.value = state.rows; opt.text = state.rows; ui.settingMarkSelect.appendChild(opt);
                    }
                 }
                 ui.settingMarkSelect.value = state.rows;
            }
        }

        function handleCsvUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            state.csvFileName = file.name;
            updateCsvUi();
            const reader = new FileReader();
            reader.onload = function(e) { parseAndApplyCsv(e.target.result); };
            reader.readAsText(file);
        }

        function parseAndApplyCsv(csvText) {
            const lines = csvText.split(/\r?\n/).filter(r => r.trim() !== '');
            if (lines.length === 0) return;

            let maxCols = 0;
            const tempRows = lines.map(line => {
                const cells = line.split(',');
                if (cells.length > maxCols) maxCols = cells.length;
                return cells;
            });

            const normalizedData = tempRows.map(row => {
                while (row.length < maxCols) { row.push(""); }
                return row.map(cell => cell.trim());
            });

            state.data = normalizedData;
            state.rows = normalizedData.length;

            if (state.chartType === 'stackedBar') {
                const currentTotal = getTotalStackedCols();
                if (maxCols !== currentTotal) {
                    state.cols = 1; 
                    state.groupStructure = [maxCols];
                }
            } else {
                state.cols = maxCols;
            }

            state.dataMode = 'raw'; 
            updateSettingInputs(); renderGrid(); updateCsvUi(); ui.csvInput.value = '';
        }

        function toggleMode() {
             const textBtnClass = 'bg-transparent border-0 text-primary hover:text-primary-hover font-semibold text-xs cursor-pointer transition-colors min-w-[40px]';
             if (state.mode === 'edit') {
                state.mode = 'read';
                ui.editModeBtn.textContent = "Edit";
                ui.editModeBtn.className = textBtnClass;
                ui.settingColInput.disabled = true; 
                ui.settingCellInput.disabled = true;
                ui.settingMarkSelect.disabled = true;
                ui.settingYMin.disabled = true;
                ui.settingYMax.disabled = true;
             } else {
                state.mode = 'edit';
                ui.editModeBtn.textContent = "Save";
                ui.editModeBtn.className = textBtnClass;
                ui.settingColInput.disabled = false; 
                ui.settingCellInput.disabled = false;
                ui.settingMarkSelect.disabled = false;
                ui.settingYMin.disabled = false;
                ui.settingYMax.disabled = false;
             }
             renderGrid(); checkCtaValidation(); 
        }

        function checkCtaValidation() {
            if (state.mode !== 'read') { ui.mainCta.disabled = true; return; }
            let isAllFilled = true;
            let isRangeError = false;
            
            const totalVisualRows = state.data.length;
            const totalCols = state.data.length > 0 ? state.data[0].length : 0;

            for (let i = 0; i < totalVisualRows; i++) {
                for (let j = 0; j < totalCols; j++) {
                    const val = state.data[i][j];
                    if (!val || val.trim() === "") isAllFilled = false;
                    if (state.dataMode === 'percent' && val && val.trim() !== "") {
                        const num = Number(val);
                        if (!isNaN(num) && (num < 0 || num > 100)) isRangeError = true;
                    }
                }
            }
            const toast = ui.errorToast;
            if (isRangeError) {
                if (toast.classList.contains('hidden')) { toast.classList.remove('hidden'); setTimeout(() => toast.classList.remove('opacity-0', 'translate-y-2'), 10); }
            } else {
                if (!toast.classList.contains('hidden') && !toast.classList.contains('opacity-0')) { toast.classList.add('opacity-0', 'translate-y-2'); setTimeout(() => toast.classList.add('hidden'), 300); }
            }
            ui.mainCta.disabled = !(isAllFilled && !isRangeError);
        }

        function submitData() {
            // 1. 현재 데이터 복사 (숫자로 변환)
            let finalValues = state.data.map(row => 
                row.map(cell => {
                    const num = Number(cell);
                    return isNaN(num) ? 0 : num;
                })
            );
            
            // 2. 변수 초기화
            let rawValues = finalValues;    // 저장용 (All 포함 전체)
            let drawingValues = finalValues; // 그리기용 (All 제외 예정)
            
            // 기본적으로 markNumPayload는 그룹 구조(배열)를 따름
            let markNumPayload = state.groupStructure; 
            
            // 3. 차트 타입 체크 및 데이터 가공
            // 'stackedBar' 뿐만 아니라 혹시 모를 'stacked' 등 변형된 이름도 방어
            if (state.chartType === 'stackedBar' || state.chartType === 'stacked') {
                
                // [핵심 Fix] Stacked Bar는 무조건 첫 번째 줄(All)을 잘라내고 보냄
                if (finalValues.length > 1) {
                    drawingValues = finalValues.slice(1);
                }
                
                // [핵심 Fix] Stacked Bar는 markNumPayload가 무조건 그룹 구조(Array)여야 함
                // 여기서 state.rows를 할당하지 않도록 보장
                markNumPayload = state.groupStructure;

            } else {
                // 일반 Bar, Line 차트일 경우에만 Rows 개수를 markNum으로 사용
                markNumPayload = state.rows; 
            }

            const msgType = state.uiMode === 'create' ? 'generate' : 'apply';
            
            // 4. Figma로 전송
            parent.postMessage({ 
                pluginMessage: { 
                    type: msgType, 
                    payload: {
                        type: state.chartType,
                        mode: state.dataMode, 
                        values: drawingValues, // 그리기용 (All 제외됨)
                        rawValues: rawValues,  // 저장용 (All 포함됨)
                        
                        // Stacked Bar는 All 행을 빼고(rows-1) 알려줌
                        rows: (state.chartType === 'stackedBar' || state.chartType === 'stacked') ? (state.rows - 1) : state.rows,
                        cols: state.cols,
                        cellCount: state.cellCount,
                        yMin: Number(ui.settingYMin.value),
                        yMax: Number(ui.settingYMax.value),
                        markNum: markNumPayload // 이제 Array([2, 2...])가 전송됨
                    }
                } 
            }, '*');
        }

        ui.editModeBtn.addEventListener('click', toggleMode);
        ui.csvInput.addEventListener('change', handleCsvUpload);
        ui.csvDeleteBtn.addEventListener('click', removeCsv);
        ui.mainCta.addEventListener('click', submitData);
        
        ui.settingColInput.addEventListener('input', handleDimensionInput);
        ui.settingCellInput.addEventListener('input', handleDimensionInput); 
        ui.settingMarkSelect.addEventListener('change', handleDimensionInput);
        
        ui.addColFixedBtn.addEventListener('click', addColumn);
        ui.addRowFixedBtn.addEventListener('click', addRow);
        ui.csvExportBtn.addEventListener('click', downloadCsv);
        ui.resetBtn.addEventListener('click', resetData);
    </script>
</body>
</html>