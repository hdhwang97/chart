<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chart Data Setting</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#18A0FB',
                        'primary-hover': '#0D86D8',
                        surface: '#F9F9F9',
                        border: '#E0E0E0',
                        'border-strong': '#BDBDBD',
                        danger: '#F24822',
                        text: '#333333',
                        'text-sub': '#888888',
                        // Custom Grays for Charts
                        'chart-gray-400': '#9CA3AF',
                        'chart-gray-500': '#6B7280',
                        'chart-highlight': '#0EA5E9'
                    },
                    fontSize: {
                        xxs: '10px',
                        xs: '11px',
                        sm: '12px'
                    },
                    boxShadow: {
                        'left-scroll': '-4px 0 12px -4px rgba(0, 0, 0, 0.1)',
                        'top-scroll': '0 -4px 12px -4px rgba(0, 0, 0, 0.1)'
                    }
                }
            }
        }
    </script>

    <style>
        body { font-family: 'Inter', sans-serif; }
        .step { display: none; opacity: 0; transform: translateY(2px); transition: all 0.3s ease-in-out; }
        .step.active { display: flex; opacity: 1; transform: translateY(0); }
        
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-thumb { background: #D1D5DB; border-radius: 4px; }
        ::-webkit-scrollbar-track { background: transparent; }

        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

        .tooltip-trigger:hover .tooltip-content { display: block; }

        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { 
            -webkit-appearance: inner-spin-button !important;
            opacity: 1 !important;
            cursor: pointer;
            display: block;
        }
        
        /* Row Header Hover Effects */
        .row-header:hover .del-row-btn { display: flex; }
        
        /* Hover Header Highlight Effect */
        .header-hover { background-color: #E0F2FE !important; color: #0284C7 !important; transition: all 0.2s; }
    </style>
</head>
<body class="bg-white text-text flex flex-col h-screen box-border text-xs overflow-hidden">

    <header class="flex justify-between items-center h-12 shrink-0 px-3 border-b border-border bg-white z-50">
    <div class="flex items-center">
        <button id="back-btn" class="hidden text-text-sub hover:text-text bg-transparent border-0 cursor-pointer p-1 mr-1" title="Back">
            <svg class="w-4 h-4 fill-current" viewBox="0 0 24 24"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
        </button>
        
        <h1 class="text-sm font-semibold flex items-center gap-2 m-0">
            Chart Data 
            <div id="chart-type-wrapper" class="hidden flex items-center gap-1.5 bg-surface border border-border px-2 py-0.5 rounded text-text-sub">
                <span id="chart-type-icon" class="flex items-center justify-center"></span>
                <span id="chart-type-display" class="text-xxs font-medium uppercase tracking-wide">Bar</span>
            </div>
        </h1>

        <div class="flex bg-surface rounded p-0.5 border border-border ml-4">
            <button id="tab-data" class="px-3 py-0.5 text-xs font-semibold rounded bg-white shadow-sm text-primary transition-all border-0 cursor-pointer" onclick="switchTab('data')">Data</button>
            <button id="tab-export" class="px-3 py-0.5 text-xs font-semibold rounded text-text-sub hover:text-text bg-transparent transition-all border-0 cursor-pointer" onclick="switchTab('export')">Export</button>
        </div>
    </div>

    <div class="flex items-center gap-2">
        <button id="edit-mode-btn" class="hidden bg-transparent border-0 text-primary hover:text-primary-hover font-semibold text-xs cursor-pointer transition-colors min-w-[40px]">Save</button>
        <button id="main-cta" disabled class="bg-primary text-white px-3 py-1.5 rounded font-semibold text-xs cursor-pointer transition-colors hover:bg-primary-hover disabled:bg-surface disabled:text-text-sub disabled:border disabled:border-border disabled:cursor-not-allowed">Apply to Figma</button>
    </div>
</header>

<div id="step-1" class="step active flex-col gap-3 w-full p-3">
    <div class="border border-border rounded-md p-3 bg-white flex flex-col gap-2">
        <h2 class="text-xs font-semibold text-text-sub m-0 mb-1">Select Chart Type</h2>
        <div class="grid grid-cols-2 gap-3 mt-2">
            <button class="bg-white border border-border rounded-md py-6 px-3 flex flex-col items-center justify-center cursor-pointer transition-all hover:border-primary hover:bg-blue-50 hover:shadow-sm" onclick="selectType('bar')">
                <svg class="w-8 h-8 fill-primary mb-2" viewBox="0 0 24 24"><path d="M4 19h4v-7H4v7zm6 0h4V9h-4v10zm6-14v14h4V5h-4zm2-4H2v22h22V1h-2z"/></svg>
                <span class="font-semibold text-text">Bar Chart</span>
            </button>
            <button class="bg-white border border-border rounded-md py-6 px-3 flex flex-col items-center justify-center cursor-pointer transition-all hover:border-primary hover:bg-blue-50 hover:shadow-sm" onclick="selectType('line')">
                <svg class="w-8 h-8 fill-primary mb-2" viewBox="0 0 24 24"><path d="M3.5 18.49l6-6.01 4 4L22 6.92l-1.41-1.41-7.09 7.97-4-4L2 16.99z"/></svg>
                <span class="font-semibold text-text">Line Chart</span>
            </button>
            <button class="bg-white border border-border rounded-md py-6 px-3 flex flex-col items-center justify-center cursor-pointer transition-all hover:border-primary hover:bg-blue-50 hover:shadow-sm" onclick="selectType('stackedBar')">
                <svg class="w-8 h-8 fill-primary mb-2" viewBox="0 0 24 24"><path d="M4 19h4v-4H4v4zm0-5h4v-3H4v3zm0-4h4V7H4v3zm6 9h4v-8h-4v8zm0-9h4V7h-4v3zm0-4h4V7h-4v3zm0-4h4V2h-4v4zm6 13h4v-6h-4v6zm0-7h4V7h-4v3zm0-4h4V2h-4v4z"/></svg>
                <span class="font-semibold text-text">Stacked Bar</span>
            </button>
        </div>
    </div>
</div>

<div id="step-2" class="step flex-col w-full h-full overflow-hidden bg-surface">
    <div class="px-3 pt-3 pb-1 shrink-0 flex flex-col gap-1.5">
        <h2 class="text-[11px] font-bold text-text-sub uppercase tracking-wider ml-1">Graph Setting</h2>
        <div class="bg-white border border-border rounded-md p-3 flex flex-col shadow-sm gap-2">
            <div class="flex items-center gap-3">
                <div class="flex flex-col gap-1 flex-1">
                    <label id="label-col-input" class="text-xxs font-medium text-text-sub">Graph Col</label>
                    <input type="number" id="setting-col-input" value="3" min="1" max="12" class="w-full px-2 py-1 border border-border rounded text-xs h-7 focus:border-primary focus:outline-none transition-colors">
                </div>
                <div class="flex flex-col gap-1 flex-1">
                    <label class="text-xxs font-medium text-text-sub">Cell Count</label>
                    <input type="number" id="setting-cell-input" value="4" min="1" max="10" class="w-full px-2 py-1 border border-border rounded text-xs h-7 focus:border-primary focus:outline-none transition-colors">
                </div>
                <div class="flex flex-col gap-1 flex-1">
                    <div id="container-mark-wrapper">
                        <label id="label-mark-position" class="text-xxs font-medium text-text-sub">Mark Count</label>
                        <div id="container-mark-normal" class="relative">
                            <select id="setting-mark-select" class="w-full px-2 py-1 border border-border rounded text-xs h-7 focus:border-primary focus:outline-none appearance-none bg-white cursor-pointer hover:border-text-sub transition-colors">
                                <option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option>
                            </select>
                            <div class="absolute right-2 top-1/2 -translate-y-1/2 pointer-events-none text-text-sub"><svg class="w-2.5 h-2.5 fill-current" viewBox="0 0 24 24"><path d="M7 10l5 5 5-5z"/></svg></div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="flex items-center gap-3 border-t border-border pt-2 mt-1">
                <div class="flex flex-col gap-1 flex-1">
                    <label class="text-xxs font-medium text-text-sub">Y Min</label>
                    <input type="number" id="setting-y-min" value="0" class="w-full px-2 py-1 border border-border rounded text-xs h-7 focus:border-primary focus:outline-none transition-colors">
                </div>
                <div class="flex flex-col gap-1 flex-1">
                    <label class="text-xxs font-medium text-text-sub">Y Max</label>
                    <input type="number" id="setting-y-max" value="100" class="w-full px-2 py-1 border border-border rounded text-xs h-7 focus:border-primary focus:outline-none transition-colors">
                </div>
                <div class="flex-1"></div> 
            </div>
        </div>
    </div>

    <div class="px-3 py-1 flex-1 flex flex-col gap-1.5 overflow-hidden pb-3">
        <h2 class="text-[11px] font-bold text-text-sub uppercase tracking-wider ml-1">Data Setting</h2>
        <div class="flex flex-col gap-2 h-full">
            <div id="preview-section" class="bg-white border border-border rounded-md p-2 shadow-sm shrink-0 flex flex-col gap-2">
                <div class="flex items-center justify-between">
                        <span class="text-[11px] font-bold text-text-sub uppercase tracking-wider">Preview</span>
                        <span class="text-xxs text-text-sub">* Hover grid headers to highlight</span>
                </div>
                <div id="chart-preview-container" class="w-full h-52 bg-surface rounded border border-border flex items-center justify-center overflow-hidden relative">
                    <span class="text-text-sub text-xs">Generating Preview...</span>
                </div>
            </div>
            <div class="bg-white border border-border rounded-md px-3 py-2 shadow-sm shrink-0 flex items-center justify-between">
                <div class="flex items-center gap-2 overflow-hidden">
                        <span class="text-xs font-semibold text-text-sub shrink-0">CSV</span>
                        <div class="w-[1px] h-3 bg-border shrink-0"></div>
                        <span id="csv-status-text" class="text-xs text-text-sub truncate">csv를 업로드해주세요.</span>
                </div>
                <div class="flex items-center gap-2 shrink-0">
                    <button id="csv-delete-btn" class="hidden w-5 h-5 flex items-center justify-center rounded-full bg-gray-100 hover:bg-danger hover:text-white text-gray-500 transition-colors cursor-pointer" title="Remove CSV"><svg class="w-3 h-3 fill-current" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 17.59 13.41 12z"/></svg></button>
                    <button id="csv-export-btn" class="text-text-sub hover:text-primary p-1 rounded transition-colors" title="Export CSV"><svg class="w-3.5 h-3.5 fill-current" viewBox="0 0 24 24"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg></button>
                    <label for="csv-upload" class="bg-white border border-border rounded px-2 py-1 text-xxs font-medium text-text cursor-pointer hover:border-text-sub hover:bg-gray-50 transition-all whitespace-nowrap">Upload</label>
                    <input type="file" id="csv-upload" accept=".csv" class="hidden">
                </div>
            </div>
            <div id="editor-card" class="bg-white border border-border rounded-md shadow-sm flex flex-col flex-1 overflow-hidden">
                <div class="px-3 border-b border-border flex justify-between items-center bg-white shrink-0 h-9">
                    <button id="reset-btn" class="text-text-sub hover:text-primary hover:bg-surface border border-transparent hover:border-border rounded px-1.5 py-0.5 text-xxs font-medium transition-all flex items-center gap-1 cursor-pointer">
                        <svg class="w-3 h-3 fill-current" viewBox="0 0 24 24"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
                        초기화
                    </button>
                    <div class="flex items-center gap-1.5">
                        <div id="mode-toggle-container" class="flex bg-surface rounded p-0.5 border border-border relative transition-colors duration-200">
                            <button id="mode-raw" class="px-2 py-0.5 text-xxs font-semibold rounded bg-white text-primary shadow-sm transition-all" onclick="setMode('raw')">Raw</button>
                            <button id="mode-percent" class="px-2 py-0.5 text-xxs font-semibold rounded text-text-sub hover:text-text transition-all" onclick="setMode('percent')">%</button>
                        </div>
                        <div class="relative tooltip-trigger cursor-help">
                            <svg class="w-3.5 h-3.5 fill-text-sub hover:fill-primary transition-colors" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/></svg>
                            <div id="main-tooltip" class="tooltip-content hidden absolute right-0 mt-2 w-52 bg-gray-800 text-white text-xxs rounded p-2 z-50 shadow-lg text-left leading-relaxed">
                                <div id="tooltip-normal">
                                    <p class="mb-1"><strong class="text-primary-hover">Raw:</strong> 입력값의 제한이 없습니다.</p>
                                    <p><strong class="text-primary-hover">%:</strong> 0~100 사이의 비율값으로 보여집니다.</p>
                                    <p id="tooltip-stacked-hint" class="hidden text-[10px] text-gray-400 mt-1 pt-1 border-t border-gray-600">* Stacked Bar: Row 1은 All(Total) 목표값입니다.</p>
                                </div>
                                <div id="tooltip-warning" class="hidden text-danger font-medium">⚠️ % 모드에서는 0~100 사이의 값만 입력할 수 있습니다.</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="grid-container-wrapper" class="flex flex-1 relative overflow-hidden bg-white">
                    <div class="flex flex-col border-t border-border z-10 shadow-left-scroll bg-surface shrink min-w-[72px]">
                        <div id="header-corner-tl" class="h-6 border-r border-b border-border-strong bg-surface shrink-0"></div>
                        <div id="row-header-container" class="overflow-hidden flex-col no-scrollbar pb-10"></div>
                    </div>
                    <div id="grid-scroll-area" class="flex-1 overflow-auto relative scroll-smooth">
                        <div id="data-grid" class="grid gap-0 border-t border-l border-border w-fit"></div>
                    </div>
                    <div class="w-8 shrink-0 border-l border-b border-t border-border bg-white flex flex-col z-20 shadow-left-scroll">
                        <div id="header-corner-tr" class="h-6 border-b border-border-strong bg-surface flex items-center justify-center shrink-0"><svg class="w-3 h-3 fill-text-sub" viewBox="0 0 0 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg></div>
                        <button id="add-col-fixed-btn" class="flex-1 w-full text-primary hover:bg-surface flex items-center justify-center cursor-pointer font-medium text-lg focus:outline-none active:bg-blue-50 transition-colors" title="Add Column / Group">+</button>
                    </div>
                </div>
                <div class="h-7 flex shrink-0 border-t border-border bg-white z-20 shadow-top-scroll">
                    <button id="add-row-fixed-btn" class="flex-1 text-primary hover:bg-surface flex items-center justify-center cursor-pointer text-xs font-medium focus:outline-none active:bg-blue-50 transition-colors">+ Add Row</button>
                    <div class="w-8 shrink-0 border-l border-border bg-surface"></div>
                </div>
            </div>
        </div>
    </div>
</div> 
<div id="step-export" class="step flex-col gap-3 w-full p-3 h-full overflow-hidden bg-surface">
    <div class="bg-white border border-border rounded-md p-3 flex flex-col gap-2 shadow-sm h-1/2 shrink-0">
        <div class="flex justify-between items-center">
            <h2 class="text-xs font-semibold text-text-sub m-0">D3.js Preview</h2>
            <span class="text-[10px] text-gray-400">*Based on Figma Styles</span>
        </div>
        <div id="d3-preview-container" class="w-full flex-1 border border-border rounded bg-white flex items-center justify-center overflow-hidden relative">
            <span class="text-text-sub text-xs">Loading Style...</span>
        </div>
    </div>

    <div class="bg-white border border-border rounded-md p-3 flex flex-col gap-2 shadow-sm flex-1 overflow-hidden">
        <div class="flex justify-between items-center shrink-0">
            <h2 class="text-xs font-semibold text-text-sub m-0">Export Code</h2>
            <button onclick="copyToClipboard()" class="text-primary text-xs hover:text-primary-hover font-medium bg-transparent border-0 cursor-pointer flex items-center gap-1">
                <svg class="w-3 h-3 fill-current" viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>
                Copy
            </button>
        </div>
        <textarea id="d3-code-output" class="w-full h-full p-2 text-[10px] font-mono border border-border rounded bg-gray-50 resize-none focus:outline-none focus:border-primary text-text leading-relaxed" readonly spellcheck="false"></textarea>
    </div>
</div>

<div id="error-toast" class="hidden fixed bottom-16 left-1/2 -translate-x-1/2 bg-danger text-white text-xs px-4 py-2.5 rounded-md shadow-lg z-50 flex items-center gap-2 transition-all duration-300 opacity-0 translate-y-2 pointer-events-none">
    <svg class="w-4 h-4 fill-white shrink-0" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/></svg>
    <span>% 모드는 0~100 사이의 값이어야 합니다.</span>
</div>
<div id="restore-toast" class="hidden fixed bottom-14 left-1/2 -translate-x-1/2 bg-gray-800 text-white text-xs px-4 py-3 rounded-md shadow-lg z-50 flex items-center gap-4 transition-all duration-300 opacity-0 translate-y-2">
    <span>저장된 데이터를 불러올까요?</span>
    <div class="flex items-center gap-3">
        <button id="toast-yes-btn" class="font-bold text-primary hover:text-blue-300 cursor-pointer">예</button>
        <button id="toast-close-btn" class="text-gray-400 hover:text-white cursor-pointer">✕</button>
    </div>
</div>


    <script>
        const MAX_SIZE = 25;
        const state = {
            rows: 3,        
            cols: 3, 
            cellCount: 4,
            groupStructure: [2, 2, 2],
            data: [], 
            mode: 'edit', chartType: 'bar', 
            dataMode: 'raw', 
            currentStep: 1,
            csvFileName: null,
            uiMode: 'create',
            cachedRawData: null, 
            conversionMax: 100 
        };
        
        const CHART_ICONS = {
            bar: `<svg class="w-3 h-3 fill-current" viewBox="0 0 24 24"><path d="M4 19h4v-7H4v7zm6 0h4V9h-4v10zm6-14v14h4V5h-4zm2-4H2v22h22V1h-2z"/></svg>`,
            line: `<svg class="w-3 h-3 fill-current" viewBox="0 0 24 24"><path d="M3.5 18.49l6-6.01 4 4L22 6.92l-1.41-1.41-7.09 7.97-4-4L2 16.99z"/></svg>`,
            stackedBar: `<svg class="w-3 h-3 fill-current" viewBox="0 0 24 24"><path d="M4 19h4v-4H4v4zm0-5h4v-3H4v3zm0-4h4V7H4v3zm6 9h4v-8h-4v8zm0-9h4V7h-4v3zm0-4h4V7h-4v3zm0-4h4V2h-4v4zm6 13h4v-6h-4v6zm0-7h4V7h-4v3zm0-4h4V2h-4v4z"/></svg>`
        };

        const ui = {
            step1: document.getElementById('step-1'),
            step2: document.getElementById('step-2'),
            backBtn: document.getElementById('back-btn'),
            mainCta: document.getElementById('main-cta'),
            editModeBtn: document.getElementById('edit-mode-btn'), 
            
            chartTypeWrapper: document.getElementById('chart-type-wrapper'),
            chartTypeIcon: document.getElementById('chart-type-icon'),
            chartTypeDisplay: document.getElementById('chart-type-display'),
            
            settingColInput: document.getElementById('setting-col-input'),
            settingCellInput: document.getElementById('setting-cell-input'),
            settingMarkSelect: document.getElementById('setting-mark-select'),
            
            containerMarkWrapper: document.getElementById('container-mark-wrapper'),
            containerMarkNormal: document.getElementById('container-mark-normal'),
            
            labelColInput: document.getElementById('label-col-input'),
            labelMarkPosition: document.getElementById('label-mark-position'),

            settingYMin: document.getElementById('setting-y-min'),
            settingYMax: document.getElementById('setting-y-max'),
            
            csvInput: document.getElementById('csv-upload'),
            csvStatusText: document.getElementById('csv-status-text'),
            csvDeleteBtn: document.getElementById('csv-delete-btn'), 
            
            gridScrollArea: document.getElementById('grid-scroll-area'),
            gridContainer: document.getElementById('data-grid'),
            rowHeaderContainer: document.getElementById('row-header-container'), 
            
            addColFixedBtn: document.getElementById('add-col-fixed-btn'),
            addRowFixedBtn: document.getElementById('add-row-fixed-btn'),
            resetBtn: document.getElementById('reset-btn'),

            modeToggleContainer: document.getElementById('mode-toggle-container'),
            modeRawBtn: document.getElementById('mode-raw'),
            modePercentBtn: document.getElementById('mode-percent'),
            
            tooltipNormal: document.getElementById('tooltip-normal'),
            tooltipWarning: document.getElementById('tooltip-warning'),
            mainTooltip: document.getElementById('main-tooltip'),
            tooltipStackedHint: document.getElementById('tooltip-stacked-hint'),

            csvExportBtn: document.getElementById('csv-export-btn'),
            toast: document.getElementById('restore-toast'),
            toastYesBtn: document.getElementById('toast-yes-btn'),
            toastCloseBtn: document.getElementById('toast-close-btn'),
            errorToast: document.getElementById('error-toast') 
        };

        ui.gridScrollArea.addEventListener('scroll', () => {
            if(ui.rowHeaderContainer) {
                ui.rowHeaderContainer.scrollTop = ui.gridScrollArea.scrollTop;
            }
        });

        function getTotalStackedCols() {
            return state.groupStructure.reduce((a, b) => a + b, 0);
        }

        function checkDataRange() {
            if(state.dataMode === 'raw') return true; 
            const totalVisualRows = state.data.length;
            const totalCols = state.data.length > 0 ? state.data[0].length : 0;
            for (let i = 0; i < totalVisualRows; i++) {
                for (let j = 0; j < totalCols; j++) {
                    const val = state.data[i][j];
                    if (val && val.trim() !== "") {
                        const num = Number(val);
                        if (!isNaN(num) && (num < 0 || num > 100)) return false; 
                    }
                }
            }
            return true;
        }

        function clearRangeErrors() {
            ui.gridContainer.querySelectorAll('input').forEach(input => {
                const wrapper = input.parentElement;
                wrapper.classList.remove('bg-red-50', 'bg-red-200'); 
                const row = parseInt(input.dataset.row);
                if (state.chartType === 'stackedBar' && row === 0) {
                    wrapper.classList.add('bg-blue-50');
                } else {
                    wrapper.classList.add((row % 2 === 1) ? 'bg-surface' : 'bg-white');
                }
                input.classList.remove('text-danger', 'font-medium', 'font-bold');
            });
        }

        function updateModeButtonState() {
            if(state.dataMode === 'percent') {
                 ui.modePercentBtn.className = 'px-2 py-0.5 text-xxs font-semibold rounded bg-white text-primary shadow-sm transition-all';
                 ui.modeRawBtn.className = 'px-2 py-0.5 text-xxs font-semibold rounded text-text-sub hover:text-text transition-all';
            } else {
                 ui.modePercentBtn.className = 'px-2 py-0.5 text-xxs font-semibold rounded text-text-sub hover:text-text transition-all';
                 ui.modeRawBtn.className = 'px-2 py-0.5 text-xxs font-semibold rounded bg-white text-primary shadow-sm transition-all';
            }
        }

        window.setMode = function(targetMode) {
            if (state.dataMode === targetMode) return;
            if (state.dataMode === 'raw' && targetMode === 'percent') {
                state.cachedRawData = JSON.parse(JSON.stringify(state.data));
                let maxVal = 0;
                state.data.forEach(row => { row.forEach(val => { const num = Number(val); if (!isNaN(num) && num > maxVal) maxVal = num; }); });
                if (maxVal === 0) maxVal = 100; state.conversionMax = maxVal;
                state.data = state.data.map(row => row.map(val => { if(val==="")return""; const num=Number(val); if(isNaN(num))return val; return String(Math.round((num/maxVal)*100*10)/10); }));
                state.dataMode = 'percent';
            } else if (state.dataMode === 'percent' && targetMode === 'raw') {
                if (state.cachedRawData) { state.data = state.cachedRawData; state.cachedRawData = null; }
                else { state.data = state.data.map(row => row.map(val => { if(val==="")return""; const num=Number(val); if(isNaN(num))return val; return String(Math.round((num/100)*state.conversionMax)); })); }
                state.dataMode = 'raw';
            }
            const isValid = checkDataRange();
            if(!isValid && state.dataMode === 'percent') { ui.tooltipNormal.classList.add('hidden'); ui.tooltipWarning.classList.remove('hidden'); }
            else { ui.tooltipNormal.classList.remove('hidden'); ui.tooltipWarning.classList.add('hidden'); clearRangeErrors(); }
            updateModeButtonState(); renderGrid();
        };

        function downloadCsv() { 
            let csvContent = "data:text/csv;charset=utf-8,";
            state.data.forEach(rowArray => {
                let row = rowArray.join(",");
                csvContent += row + "\r\n";
            });
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "chart_data.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function showToast() { ui.toast.classList.remove('hidden'); setTimeout(() => { ui.toast.classList.remove('opacity-0', 'translate-y-2'); }, 50); }
        function hideToast() { ui.toast.classList.add('opacity-0', 'translate-y-2'); setTimeout(() => { ui.toast.classList.add('hidden'); }, 300); }
        ui.toastCloseBtn.addEventListener('click', hideToast);
        ui.toastYesBtn.addEventListener('click', () => { hideToast(); });
        function updateCsvUi() { 
            const isUploaded = !!state.csvFileName;
            ui.csvStatusText.textContent = isUploaded ? state.csvFileName : "csv를 업로드해주세요.";
            ui.csvStatusText.className = isUploaded ? 'text-xs text-primary font-semibold truncate' : 'text-xs text-text-sub truncate';
            isUploaded ? ui.csvDeleteBtn.classList.remove('hidden') : ui.csvDeleteBtn.classList.add('hidden');
        }
        function removeCsv() { state.csvFileName = null; ui.csvInput.value = ''; updateCsvUi(); }

        function updateHeaderIcon() {
            let displayType = 'Bar';
            if(state.chartType === 'line') displayType = 'Line';
            else if(state.chartType === 'stackedBar') displayType = 'Stacked';
            ui.chartTypeDisplay.textContent = displayType;
            ui.chartTypeIcon.innerHTML = CHART_ICONS[state.chartType] || CHART_ICONS['bar'];
            
            if(state.chartType === 'stackedBar') ui.tooltipStackedHint.classList.remove('hidden');
            else ui.tooltipStackedHint.classList.add('hidden');
        }

        function goToStep(stepNum) {
            state.currentStep = stepNum;
            document.querySelectorAll('.step').forEach(el => el.classList.remove('active'));
            if (stepNum === 1) {
                ui.step1.classList.add('active');
                ui.backBtn.classList.add('hidden');
                ui.chartTypeWrapper.classList.add('hidden'); 
                ui.mainCta.style.display = 'none';
                ui.editModeBtn.classList.add('hidden'); 
                removeCsv();
                state.uiMode = 'create';
            } else {
                ui.step2.classList.add('active');
                ui.backBtn.classList.remove('hidden');
                ui.chartTypeWrapper.classList.remove('hidden'); 
                
                const targetHeight = state.chartType === 'stackedBar' ? 780 : 720; 

                updateHeaderIcon();
                ui.mainCta.style.display = 'block';
                ui.mainCta.textContent = state.uiMode === 'create' ? "Generate to Figma" : "Apply to Figma";
                ui.editModeBtn.classList.remove('hidden');
                
                try {
                    updateSettingInputs(); 
                    renderGrid();
                    checkCtaValidation();
                    updateModeButtonState(); 
                } catch (e) { console.error("Render Error:", e); }
            }
        }

        window.selectType = function(type) {
            state.chartType = type;
            resetData(); 
            goToStep(2);
        };

        ui.backBtn.addEventListener('click', () => { goToStep(1); hideToast(); });

        function initData(rows, cols) {
            const newData = [];
            for (let i = 0; i < rows; i++) {
                const row = new Array(cols).fill("");
                newData.push(row);
            }
            return newData;
        }

        window.onmessage = (event) => {
            const msg = event.data.pluginMessage;
            if (!msg) return;

            if (msg.type === 'init') {
                state.uiMode = msg.uiMode || 'create';
                
                if (msg.chartType) {
                    state.chartType = msg.chartType;
                    
                    let targetData = null;
                    let targetMarkNum = null;

                    if (msg.savedValues) {
                        targetData = msg.savedValues;
                        targetMarkNum = msg.savedMarkNum;
                    } else if (msg.inferredValues) {
                        targetData = msg.inferredValues;
                        targetMarkNum = msg.inferredMarkNum;
                    }

                    if (targetData) {
                        state.data = targetData.map(row => row.map(v => String(v)));
                        
                        if (msg.chartType === 'stackedBar') {
                            if (targetMarkNum && Array.isArray(targetMarkNum)) {
                                state.groupStructure = targetMarkNum;
                                state.cols = state.groupStructure.length;
                            } else {
                                state.cols = 1; 
                                state.groupStructure = [state.data[0].length];
                            }
                            
                            let shouldAddAllRow = false;
                            
                            if (targetData === msg.inferredValues) {
                                shouldAddAllRow = true;
                            } else if (targetData === msg.savedValues) {
                                const visualRowCount = msg.inferredValues ? msg.inferredValues.length : 0;
                                if (state.data.length <= visualRowCount) {
                                    shouldAddAllRow = true;
                                }
                            }

                            if (shouldAddAllRow) {
                                const colsCount = state.data.length > 0 ? state.data[0].length : state.cols;
                                state.data.unshift(new Array(colsCount).fill(""));
                            }
                            state.rows = state.data.length; 

                        } else {
                            state.rows = state.data.length;
                            state.cols = state.data[0].length;
                            if (msg.chartType === 'line') state.cols = Math.max(1, state.cols - 1);
                        }
                    } else {
                        // Reverted Default Initialization for Stacked Bar
                        if (msg.chartType === 'stackedBar') {
                            state.groupStructure = [2, 2, 2]; // 3 Groups, 2 Bars each
                            state.data = initData(4, 6); // All + 3 Stacks = 4 rows, 6 cols total
                            state.rows = 4;
                            state.cols = 3;
                        } else {
                            state.rows = 3; 
                            state.cols = 3;
                            state.data = initData(3, 3);
                        }
                    }
                    
                    updateSettingInputs();
                    updateModeButtonState(); 
                    goToStep(2); 
                } else {
                    state.uiMode = 'create';
                    goToStep(1); 
                }
            }
        };

        function validateStackedData() {
            if (state.chartType !== 'stackedBar') return;
            if (state.data.length < 2) return; 

            const totalCols = state.data[0].length;

            for (let c = 0; c < totalCols; c++) {
                const allValStr = state.data[0][c];
                const allVal = Number(allValStr);
                
                if (allValStr === "" || isNaN(allVal)) {
                     for (let r = 0; r < state.rows; r++) {
                         const cellInput = document.querySelector(`input[data-row="${r}"][data-col="${c}"]`);
                         if(cellInput) {
                             const wrapper = cellInput.parentElement;
                             if (wrapper.classList.contains('bg-red-200')) {
                                 wrapper.classList.remove('bg-red-200');
                                 cellInput.classList.remove('text-danger', 'font-bold');
                                 if (r === 0) wrapper.classList.add('bg-blue-50');
                                 else wrapper.classList.add((r % 2 === 1) ? 'bg-surface' : 'bg-white');
                             }
                         }
                     }
                    continue;
                }

                let stackSum = 0;
                for (let r = 1; r < state.rows; r++) {
                    const stackValStr = state.data[r][c];
                    const stackVal = Number(stackValStr);
                    const cellInput = document.querySelector(`input[data-row="${r}"][data-col="${c}"]`);
                    
                    if (cellInput) {
                        const wrapper = cellInput.parentElement;
                        let isError = false;

                        if (stackValStr !== "" && !isNaN(stackVal)) {
                            stackSum += stackVal;
                            if (stackVal > allVal) {
                                isError = true;
                                wrapper.classList.remove('bg-white', 'bg-surface');
                                wrapper.classList.add('bg-red-200');
                                cellInput.classList.add('text-danger', 'font-bold');
                            }
                        }

                        if (!isError && wrapper.classList.contains('bg-red-200')) {
                             wrapper.classList.remove('bg-red-200');
                             cellInput.classList.remove('text-danger', 'font-bold');
                             wrapper.classList.add((r % 2 === 1) ? 'bg-surface' : 'bg-white');
                        }
                    }
                }

                const allInput = document.querySelector(`input[data-row="0"][data-col="${c}"]`);
                if (allInput) {
                    const wrapper = allInput.parentElement;
                    if (stackSum > allVal) {
                        wrapper.classList.remove('bg-blue-50');
                        wrapper.classList.add('bg-red-200');
                        allInput.classList.add('text-danger', 'font-bold');
                    } else {
                        if (wrapper.classList.contains('bg-red-200')) {
                            wrapper.classList.remove('bg-red-200');
                            wrapper.classList.add('bg-blue-50');
                            allInput.classList.remove('text-danger', 'font-bold');
                        }
                    }
                }
            }
        }


        // HELPER: Stacked Bar Auto-Fill Calculation
        function getAutoFillValue(colIndex) {
            // 1. 차트 타입이 StackedBar가 아니거나, 데이터가 없으면 중단
            if (state.chartType !== 'stackedBar') return null;
            
            // 2. Total(Row 0) 값 확인
            const totalStr = state.data[0][colIndex];
            const totalVal = Number(totalStr);
            if (totalStr === "" || isNaN(totalVal)) return null;

            // 3. Stack 행들(Row 1 ~ End) 순회
            let currentSum = 0;
            let emptyCount = 0;
            let emptyRowIndex = -1;

            for (let r = 1; r < state.rows; r++) {
                const valStr = state.data[r][colIndex];
                if (valStr === "") {
                    emptyCount++;
                    emptyRowIndex = r;
                } else {
                    const val = Number(valStr);
                    if (!isNaN(val)) currentSum += val;
                }
            }

            // 4. 조건 충족 확인: 빈 칸이 딱 1개일 때
            if (emptyCount === 1) {
                let remainder = totalVal - currentSum;
                // 0보다 작은 경우(Total보다 합이 큰 경우)는 사용자 판단에 맡기기 위해 그대로 노출하거나, 
                // 필요하다면 Math.max(0, remainder) 처리를 할 수 있습니다. 현재는 그대로 반환합니다.
                const displayValue = Number.isInteger(remainder) ? String(remainder) : remainder.toFixed(1).replace('.0','');
                
                return {
                    rowIndex: emptyRowIndex,
                    value: displayValue
                };
            }

            return null;
        }
        

        // MAIN GRID RENDERER (Updated with Auto-Fill Preview)
        // ==========================================
        function renderGrid() {
            ui.gridContainer.innerHTML = ''; 
            ui.rowHeaderContainer.innerHTML = ''; 
            
            if (!state.data || state.data.length === 0) return;
            let gridCols = state.data[0].length;
            
            // 콘텐츠 길이에 맞춰 최소 너비 자동 조절
            ui.gridContainer.style.gridTemplateColumns = `repeat(${gridCols}, minmax(auto, 1fr))`;

            // [HEADER AREA] - (이전 수정사항 유지)
            if (state.chartType === 'stackedBar') {
                // ... (이전과 동일한 Header 생성 로직) ...
                for (let g = 0; g < state.groupStructure.length; g++) { 
                    const groupHeader = document.createElement('div');
                    groupHeader.id = `header-group-${g}`;
                    const spanCount = state.groupStructure[g];
                    groupHeader.style.gridColumn = `span ${spanCount}`;
                    groupHeader.className = 'sticky top-0 z-30 bg-gray-100 border-r-2 border-b border-border-strong flex items-center justify-between px-2 h-6 text-xxs font-bold text-text group relative cursor-pointer hover:bg-blue-50';

                    if (state.mode === 'edit') {
                        const addBarBtn = document.createElement('button');
                        addBarBtn.id = `btn-add-bar-group-${g}`;
                        addBarBtn.className = 'w-4 h-4 flex items-center justify-center bg-transparent border-0 cursor-pointer text-gray-400 hover:text-primary shrink-0';
                        addBarBtn.innerHTML = `<svg class="w-3 h-3 fill-current" viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>`;
                        addBarBtn.onclick = (e) => { e.stopPropagation(); addBarToGroup(g); };
                        groupHeader.appendChild(addBarBtn);
                    }

                    const textSpan = document.createElement('span');
                    textSpan.textContent = `Group ${g + 1}`;
                    textSpan.className = "truncate mx-1";
                    groupHeader.appendChild(textSpan);

                    if (state.mode === 'edit') {
                        const delBtn = document.createElement('button');
                        delBtn.id = `btn-del-group-${g}`;
                        delBtn.className = 'w-4 h-4 flex items-center justify-center bg-transparent border-0 cursor-pointer text-gray-400 hover:text-danger shrink-0';
                        delBtn.innerHTML = `<svg class="w-3 h-3 fill-current" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>`;
                        delBtn.onclick = (e) => { e.stopPropagation(); deleteColumn(g); };
                        groupHeader.appendChild(delBtn);
                    }
                    
                    groupHeader.addEventListener('mouseenter', () => highlightPreview('group', g));
                    groupHeader.addEventListener('mouseleave', () => resetPreviewHighlight());
                    ui.gridContainer.appendChild(groupHeader);
                }

                let colCursor = 0;
                state.groupStructure.forEach((count, gIdx) => {
                    for (let b = 0; b < count; b++) {
                        const subHeader = document.createElement('div');
                        const actualColIndex = colCursor; 
                        subHeader.id = `header-sub-group-${gIdx}-bar-${b}`;
                        subHeader.className = 'sticky top-6 z-20 bg-surface border-r border-b border-border-strong flex items-center justify-between px-2 h-6 text-[9px] font-medium text-text-sub group relative cursor-pointer hover:text-primary';
                        
                        const textSpan = document.createElement('span');
                        textSpan.textContent = `Bar ${b + 1}`;
                        textSpan.className = "truncate";
                        subHeader.appendChild(textSpan);
                        
                        subHeader.addEventListener('mouseenter', () => { subHeader.classList.add('header-hover'); highlightPreview('col', actualColIndex); });
                        subHeader.addEventListener('mouseleave', () => { subHeader.classList.remove('header-hover'); resetPreviewHighlight(); });

                        if (state.mode === 'edit') {
                            const delSubBtn = document.createElement('button');
                            delSubBtn.id = `btn-del-sub-group-${gIdx}-bar-${b}`;
                            delSubBtn.className = 'w-3 h-3 flex items-center justify-center bg-transparent border-0 cursor-pointer text-gray-400 hover:text-danger shrink-0 ml-1';
                            delSubBtn.innerHTML = `<svg class="w-2 h-2 fill-current" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>`;
                            const currentG = gIdx; const currentB = b;
                            delSubBtn.onclick = (e) => { e.stopPropagation(); removeBarFromGroup(currentG, currentB); };
                            subHeader.appendChild(delSubBtn);
                        }
                        ui.gridContainer.appendChild(subHeader);
                        colCursor++;
                    }
                });

            } else {
                // CASE B: Normal Charts (Bar, Line)
                for (let j = 0; j < gridCols; j++) {
                    const headerCell = document.createElement('div');
                    headerCell.id = `header-col-${j}`;
                    headerCell.className = 'sticky top-0 z-20 bg-surface border-r border-b border-border-strong flex items-center justify-between px-2 h-6 text-xxs font-semibold text-text-sub group relative cursor-pointer transition-colors';
                    let colLabel = `${j + 1}`;
                    if (state.chartType === 'line') colLabel = `P ${j + 1}`;
                    
                    const textSpan = document.createElement('span');
                    textSpan.textContent = colLabel;
                    textSpan.className = "truncate";
                    headerCell.appendChild(textSpan);
                    
                    headerCell.addEventListener('mouseenter', () => { headerCell.classList.add('header-hover'); highlightPreview('col', j); });
                    headerCell.addEventListener('mouseleave', () => { headerCell.classList.remove('header-hover'); resetPreviewHighlight(); });

                    if (state.mode === 'edit') {
                        const delBtn = document.createElement('button');
                        delBtn.id = `btn-del-col-${j}`;
                        delBtn.className = 'w-4 h-4 flex items-center justify-center bg-transparent border-0 cursor-pointer text-gray-400 hover:text-danger shrink-0 ml-1';
                        delBtn.innerHTML = `<svg class="w-3 h-3 fill-current" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>`;
                        delBtn.onclick = () => deleteColumn(j);
                        headerCell.appendChild(delBtn);
                    }
                    ui.gridContainer.appendChild(headerCell);
                }
            }

            // [BODY AREA] Rows
            state.data.forEach((row, rowIndex) => {
                const isStackedAll = (state.chartType === 'stackedBar' && rowIndex === 0);
                const isZebra = (rowIndex % 2 === 1);
                let bgClass = isZebra ? 'bg-surface' : 'bg-white';
                if (isStackedAll) bgClass = 'bg-blue-50'; 

                const rowHeader = document.createElement('div');
                rowHeader.id = `header-row-${rowIndex}`;
                rowHeader.className = `row-header group relative w-full h-6 px-2 border-b border-r border-border-strong text-xxs font-semibold text-text-sub flex items-center justify-between truncate ${bgClass} cursor-pointer transition-colors`;
                
                let rowLabelText = "";
                if (state.chartType === 'line') rowLabelText = `Line ${rowIndex + 1}`;
                else if (state.chartType === 'stackedBar') {
                    if (rowIndex === 0) rowLabelText = `All (Total)`;
                    else rowLabelText = `Stack ${rowIndex}`;
                } else {
                    rowLabelText = `Bar ${rowIndex + 1}`;
                }
                
                const textSpan = document.createElement('span');
                textSpan.textContent = rowLabelText;
                textSpan.className = "truncate"; 
                if (isStackedAll) textSpan.classList.add('text-primary-hover', 'font-bold');
                rowHeader.appendChild(textSpan);
                
                rowHeader.addEventListener('mouseenter', () => { rowHeader.classList.add('header-hover'); highlightPreview('row', rowIndex); });
                rowHeader.addEventListener('mouseleave', () => { rowHeader.classList.remove('header-hover'); resetPreviewHighlight(); });

                if (state.mode === 'edit' && !isStackedAll) {
                    const delRowBtn = document.createElement('button');
                    delRowBtn.id = `btn-del-row-${rowIndex}`;
                    delRowBtn.innerHTML = `<svg class="w-3 h-3 fill-current" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 17.59 17.59 13.41 12 19 6.41z"/></svg>`;
                    delRowBtn.className = 'del-row-btn w-4 h-4 flex items-center justify-center bg-transparent border-0 cursor-pointer text-gray-400 hover:text-danger shrink-0';
                    delRowBtn.onclick = (e) => { e.stopPropagation(); deleteRow(rowIndex); };
                    rowHeader.appendChild(delRowBtn);
                }
                ui.rowHeaderContainer.appendChild(rowHeader);

                // Cells
                row.forEach((cellValue, colIndex) => {
                    const cellWrapper = document.createElement('div');
                    cellWrapper.className = `flex items-center w-full h-6 border-r border-b border-border-strong ${bgClass} hover:bg-blue-50 transition-colors`;
                    
                    const input = document.createElement('input');
                    input.id = `input-cell-${rowIndex}-${colIndex}`;
                    input.type = 'text'; 
                    input.value = cellValue; 
                    input.dataset.row = rowIndex; 
                    input.dataset.col = colIndex;
                    
                    // [기존] 스타일 처리
                    let isError = false; 
                    if (state.dataMode === 'percent' && cellValue !== "") { 
                        const num = Number(cellValue); 
                        if (!isNaN(num) && (num < 0 || num > 100)) isError = true; 
                    }
                    let classes = `flex-1 w-full h-full px-2 text-xs text-right focus:outline-none bg-transparent min-w-0`;
                    if (isError) { 
                        cellWrapper.classList.remove('bg-white', 'bg-surface', 'bg-blue-50'); 
                        cellWrapper.classList.add('bg-red-50'); 
                        classes += ' text-danger font-medium'; 
                    }
                    if (state.mode === 'read') classes += ' text-gray-400 cursor-not-allowed';
                    if (isStackedAll) classes += ' font-bold text-primary';

                    input.className = classes;
                    
                    // [추가됨] 자동 계산 미리보기 (Stacked Bar & Row > 0 일 때)
                    if (state.chartType === 'stackedBar' && rowIndex > 0) {
                        const showPreview = () => {
                            if (input.value !== "") return; // 값이 있으면 무시

                            const result = getAutoFillValue(colIndex);
                            // 계산 결과가 있고, 현재 셀이 바로 그 '빈 칸'이라면
                            if (result && result.rowIndex === rowIndex) {
                                input.placeholder = result.value;
                                input.classList.add('placeholder-blue-400');
                            }
                        };

                        const hidePreview = () => {
                            input.placeholder = "";
                            input.classList.remove('placeholder-blue-400');
                        };

                        input.addEventListener('mouseenter', showPreview);
                        input.addEventListener('focus', showPreview);
                        
                        input.addEventListener('mouseleave', () => {
                             // 포커스 중이 아닐 때만 마우스 나가면 지움
                             if (document.activeElement !== input) hidePreview();
                        });
                        
                        input.addEventListener('blur', hidePreview);
                    }

                    // [기존] 이벤트 리스너
                    input.addEventListener('focus', () => highlightPreview('cell', rowIndex, colIndex));
                    input.addEventListener('mouseenter', () => highlightPreview('cell', rowIndex, colIndex));
                    input.addEventListener('mouseleave', () => resetPreviewHighlight());
                    input.addEventListener('blur', () => resetPreviewHighlight());
                    
                    input.addEventListener('input', (e) => {
                        state.data[rowIndex][colIndex] = e.target.value;
                        updateModeButtonState(); 
                        
                        if (state.chartType === 'stackedBar') {
                            validateStackedData();
                        }

                        const val = e.target.value; const num = Number(val);
                        const isErr = (state.dataMode === 'percent' && val!=="" && (!isNaN(num) && (num<0 || num>100)));
                        if(isErr && !cellWrapper.classList.contains('bg-red-200')) { 
                            cellWrapper.classList.remove(bgClass); cellWrapper.classList.add('bg-red-50'); e.target.classList.add('text-danger', 'font-medium'); 
                        } else if (!cellWrapper.classList.contains('bg-red-200')) { 
                            cellWrapper.classList.remove('bg-red-50'); cellWrapper.classList.add(bgClass); e.target.classList.remove('text-danger', 'font-medium'); 
                        }
                        
                        checkCtaValidation();
                        renderPreview(); 
                    });

                    cellWrapper.appendChild(input);
                    if (state.dataMode === 'percent') {
                        const unitSpan = document.createElement('span'); 
                        unitSpan.className = 'shrink-0 pr-2 pl-0.5 text-[10px] text-text-sub pointer-events-none'; 
                        unitSpan.innerText = '%'; 
                        cellWrapper.appendChild(unitSpan);
                    }
                    ui.gridContainer.appendChild(cellWrapper);
                });
            });

            if (state.chartType === 'stackedBar') {
                ui.rowHeaderContainer.style.marginTop = '24px'; 
                validateStackedData();
            } else {
                ui.rowHeaderContainer.style.marginTop = '0px'; 
            }
            checkCtaValidation();
            renderPreview(); 
        }

        // ==========================================
        // PREVIEW SECTION (Refactored)
        // ==========================================

        const PREVIEW_OPTS = {
            padding: { top: 20, right: 80, bottom: 20, left: 80 },
            colors: {
                default: '#9CA3AF', // Gray-400
                secondary: '#6B7280', // Gray-500
                highlight: '#0EA5E9' // Sky-500
            },
            barWidthRatio: 0.6 
        };

        function renderPreview() {
            const container = document.getElementById('chart-preview-container');
            if (!container) return;

            const rows = state.rows;
            const chartType = state.chartType;
            
            const width = container.clientWidth || 300;
            const height = container.clientHeight || 208;
            
            const { padding, colors, barWidthRatio } = PREVIEW_OPTS;
            
            const drawW = width - padding.left - padding.right;
            const drawH = height - padding.top - padding.bottom;
            const svgNS = "http://www.w3.org/2000/svg";
            
            const svg = document.createElementNS(svgNS, "svg");
            svg.setAttribute("width", "100%");
            svg.setAttribute("height", "100%");
            svg.setAttribute("viewBox", `0 0 ${width} ${height}`);

            // Axis Lines
            const yAxis = document.createElementNS(svgNS, "line");
            yAxis.setAttribute("x1", padding.left); yAxis.setAttribute("y1", padding.top);
            yAxis.setAttribute("x2", padding.left); yAxis.setAttribute("y2", height - padding.bottom);
            yAxis.setAttribute("stroke", "#E0E0E0"); yAxis.setAttribute("stroke-width", "1");
            svg.appendChild(yAxis);

            const xAxis = document.createElementNS(svgNS, "line");
            xAxis.setAttribute("x1", padding.left); xAxis.setAttribute("y1", height - padding.bottom);
            xAxis.setAttribute("x2", width - padding.right); xAxis.setAttribute("y2", height - padding.bottom);
            xAxis.setAttribute("stroke", "#E0E0E0"); xAxis.setAttribute("stroke-width", "1");
            svg.appendChild(xAxis);

            let totalGridCols = 0;
            if(state.data.length > 0) totalGridCols = state.data[0].length;
            if(totalGridCols === 0) return;

            // [FIXED] Dynamic Scale Calculation
            // 1. 사용자 설정값 가져오기
            const settingYMin = Number(ui.settingYMin.value) || 0;
            const settingYMax = Number(ui.settingYMax.value) || 100;
            
            // 2. 실제 데이터의 최댓값(Max) 계산
            let dataMax = 0;
            if (chartType === 'stackedBar') {
                // Stacked Bar는 '쌓인 높이(Sum)'가 기준이 되어야 함
                for(let c = 0; c < totalGridCols; c++) {
                    let colSum = 0;
                    // Row 0(Total)은 제외하고 실제 쌓이는 Row 1부터 합산
                    for(let r = 1; r < rows; r++) {
                        const val = Number(state.data[r][c]);
                        if (!isNaN(val)) colSum += val;
                    }
                    if (colSum > dataMax) dataMax = colSum;
                }
            } else {
                // Bar, Line 차트는 개별 값 중 최댓값 찾기
                state.data.forEach(row => {
                    row.forEach(val => {
                        const num = Number(val);
                        if (!isNaN(num) && num > dataMax) dataMax = num;
                    });
                });
            }

            // 3. 최종 Y Max 결정 (설정값보다 데이터가 크면 데이터 기준, 아니면 설정값 기준)
            // Raw 모드일 때만 자동 확장을 적용합니다.
            let finalYMax = settingYMax;
            if (state.dataMode === 'raw') {
                finalYMax = Math.max(settingYMax, dataMax);
            }

            const yMin = settingYMin;
            const yRange = (finalYMax - yMin) === 0 ? 1 : (finalYMax - yMin);


            // ==========================================
            // LINE CHART RENDERING
            // ==========================================
            if (chartType === 'line') {
                const segmentWidth = drawW / state.cols; 

                for (let r = 0; r < rows; r++) {
                    let points = "";
                    let circleElements = [];
                    
                    for (let c = 0; c < totalGridCols; c++) {
                        let rawVal = "";
                        if (state.data[r] && state.data[r][c]) rawVal = state.data[r][c];
                        
                        const numVal = Number(rawVal);
                        let val = (rawVal === "" || isNaN(numVal)) ? yMin : numVal;

                        const normalizedVal = Math.max(0, val - yMin);
                        // 비율 계산 시 finalYMax 기준인 yRange 사용
                        const ratio = Math.min(Math.max(normalizedVal / yRange, 0), 1);
                        const barH = drawH * ratio;

                        const cx = padding.left + (c * segmentWidth);
                        const cy = (height - padding.bottom) - barH;

                        points += `${cx},${cy} `;

                        const circle = document.createElementNS(svgNS, "circle");
                        circle.setAttribute("cx", cx);
                        circle.setAttribute("cy", cy);
                        circle.setAttribute("r", "3");
                        circle.setAttribute("fill", colors.default);
                        circle.setAttribute("stroke", "#fff");
                        circle.setAttribute("stroke-width", "1");
                        
                        circle.setAttribute("data-row", r);
                        circle.setAttribute("data-col", c);
                        circle.setAttribute("data-original-fill", colors.default);
                        circle.classList.add('preview-mark');
                        
                        circleElements.push(circle);
                    }

                    const polyline = document.createElementNS(svgNS, "polyline");
                    polyline.setAttribute("points", points);
                    polyline.setAttribute("fill", "none");
                    polyline.setAttribute("stroke", colors.secondary);
                    polyline.setAttribute("stroke-width", "2");
                    polyline.setAttribute("stroke-linejoin", "round");
                    polyline.setAttribute("stroke-linecap", "round");
                    
                    // 호버 효과용 속성
                    polyline.setAttribute("data-row", r);
                    polyline.classList.add('preview-line');

                    svg.appendChild(polyline);
                    circleElements.forEach(circle => svg.appendChild(circle));
                }

            } else {
                // ==========================================
                // BAR / STACKED BAR RENDERING
                // ==========================================
                let colToGroupMap = [];
                if (chartType === 'stackedBar') {
                    state.groupStructure.forEach((count, gIdx) => {
                        for(let i=0; i<count; i++) {
                            colToGroupMap.push({ groupIdx: gIdx, colInGroup: i, totalInGroup: count });
                        }
                    });
                }

                for (let c = 0; c < totalGridCols; c++) {
                    let stackY = 0;

                    for (let r = 0; r < rows; r++) {
                        if (chartType === 'stackedBar' && r === 0) continue;

                        let rawVal = "";
                        if (state.data[r] && state.data[r][c]) rawVal = state.data[r][c];
                        const numVal = Number(rawVal);
                        let val = (rawVal === "" || isNaN(numVal)) ? 
                                  ((chartType === 'stackedBar') ? (finalYMax - yMin)/(rows-1) : (finalYMax - yMin)*0.7) : numVal;
                        
                        const normalizedVal = Math.max(0, val - yMin);
                        const ratio = Math.min(Math.max(normalizedVal / yRange, 0), 1);
                        const barH = drawH * ratio;

                        const rect = document.createElementNS(svgNS, "rect");
                        let x = 0, y = 0, rectWidth = 0;

                        if (chartType === 'stackedBar') {
                            const mapInfo = colToGroupMap[c];
                            if (mapInfo) {
                                const groupSlotWidth = drawW / state.groupStructure.length;
                                const effectiveBarWidth = (groupSlotWidth * barWidthRatio) / mapInfo.totalInGroup;
                                x = padding.left + (mapInfo.groupIdx * groupSlotWidth) + (groupSlotWidth * (1 - barWidthRatio) / 2) + (mapInfo.colInGroup * effectiveBarWidth);
                                y = (height - padding.bottom) - stackY - barH;
                                stackY += barH;
                                rectWidth = Math.max(0, effectiveBarWidth - 1);
                            }
                        } else {
                            let effectiveColWidth = drawW / state.cols;
                            let effectiveBarWidth = (effectiveColWidth * barWidthRatio) / rows;
                            x = padding.left + (c * effectiveColWidth) + (effectiveColWidth * (1 - barWidthRatio) / 2) + (r * effectiveBarWidth);
                            y = (height - padding.bottom) - barH;
                            rectWidth = Math.max(0, effectiveBarWidth - 1);
                        }

                        rect.setAttribute("x", x);
                        rect.setAttribute("y", y);
                        rect.setAttribute("width", rectWidth);
                        rect.setAttribute("height", Math.max(0, barH));
                        rect.setAttribute("fill", (chartType === 'stackedBar' && r % 2 === 0) ? colors.secondary : colors.default);
                        rect.setAttribute("data-original-fill", rect.getAttribute("fill"));
                        rect.setAttribute("data-row", r);
                        rect.setAttribute("data-col", c);
                        
                        rect.classList.add('preview-mark');
                        svg.appendChild(rect);
                    }
                }
            }
            container.innerHTML = '';
            container.appendChild(svg);
        }

        function highlightPreview(type, indexOrRow, colIndex) {
            const marks = document.querySelectorAll('.preview-mark');
            const lines = document.querySelectorAll('.preview-line');
            const { highlight } = PREVIEW_OPTS.colors;

            // 1. 라인(Line) 먼저 처리 (점보다 아래에 위치해야 하므로 먼저 처리)
            lines.forEach(line => {
                let shouldThicken = false;
                const r = line.getAttribute('data-row');

                if (type === 'row') {
                    if (r == indexOrRow) shouldThicken = true;
                } else if (type === 'cell') {
                    // Cell 호버 시 해당 Row 라인도 강조
                    if (r == indexOrRow) shouldThicken = true;
                }

                if (shouldThicken) {
                    line.setAttribute('stroke-width', "4");
                    line.setAttribute('stroke', highlight);
                    
                    // [핵심] 하이라이트된 라인을 DOM 맨 끝으로 이동 (최상위 노출)
                    line.parentNode.appendChild(line);
                } else {
                    line.setAttribute('stroke-width', "2");
                    line.setAttribute('stroke', PREVIEW_OPTS.colors.secondary);
                }
            });

            // 2. 마크(Point/Bar) 처리 (라인 위에 그려져야 하므로 나중에 처리)
            marks.forEach(mark => {
                let shouldHighlight = false;
                
                if (type === 'col') { 
                    if (state.chartType === 'stackedBar') {
                         if (mark.getAttribute('data-col') == indexOrRow) shouldHighlight = true;
                    } else {
                        if (mark.getAttribute('data-col') == indexOrRow) shouldHighlight = true;
                    }
                } else if (type === 'row') { 
                    if (mark.getAttribute('data-row') == indexOrRow) shouldHighlight = true;
                } else if (type === 'group') { 
                    let startCol = 0;
                    for(let i=0; i<indexOrRow; i++) startCol += state.groupStructure[i];
                    let endCol = startCol + state.groupStructure[indexOrRow];
                    
                    const c = parseInt(mark.getAttribute('data-col'));
                    if (c >= startCol && c < endCol) shouldHighlight = true;
                } else if (type === 'cell') { 
                    const r = indexOrRow;
                    const c = colIndex;
                    if (state.chartType === 'stackedBar' && r === 0) {
                        if (mark.getAttribute('data-col') == c) shouldHighlight = true;
                    } else {
                        if (mark.getAttribute('data-row') == r && mark.getAttribute('data-col') == c) shouldHighlight = true;
                    }
                }

                if (shouldHighlight) {
                    mark.setAttribute('fill', highlight);
                    
                    if (mark.tagName === 'circle') {
                        mark.setAttribute('r', "6"); // 크기 확대
                    }

                    // [핵심] 하이라이트된 마크를 DOM 맨 끝으로 이동 (최상위 노출)
                    mark.parentNode.appendChild(mark); 

                } else {
                    mark.setAttribute('fill', mark.getAttribute('data-original-fill'));
                    if (mark.tagName === 'circle') {
                        mark.setAttribute('r', "3"); // 크기 복구
                    }
                }
            });
        }

        function resetPreviewHighlight() {
            // 마크(점/바) 초기화
            const marks = document.querySelectorAll('.preview-mark');
            marks.forEach(mark => {
                mark.setAttribute('fill', mark.getAttribute('data-original-fill'));
                if (mark.tagName === 'circle') {
                    mark.setAttribute('r', "3"); // 반지름 초기화
                }
            });

            // 라인 초기화
            const lines = document.querySelectorAll('.preview-line');
            lines.forEach(line => {
                line.setAttribute('stroke-width', "2"); // 두께 초기화
                line.setAttribute('stroke', PREVIEW_OPTS.colors.secondary); // 색상 초기화
            });
        }

        // ==========================================
        // DATA MANIPULATION HELPERS
        // ==========================================

        function addBarToGroup(groupIndex) {
            if (state.groupStructure[groupIndex] >= 10) return;
            let insertAt = 0;
            for (let i = 0; i < groupIndex; i++) {
                insertAt += state.groupStructure[i];
            }
            insertAt += state.groupStructure[groupIndex]; 

            state.data.forEach(row => { row.splice(insertAt, 0, ""); });
            state.groupStructure[groupIndex]++;
            renderGrid();
        }

        function removeBarFromGroup(groupIndex, barIndex) {
            if (state.groupStructure[groupIndex] <= 1) {
                alert("Minimum 1 bar per group."); return; 
            }
            let deleteAt = 0;
            for (let i = 0; i < groupIndex; i++) {
                deleteAt += state.groupStructure[i];
            }
            deleteAt += barIndex;
            state.data.forEach(row => { row.splice(deleteAt, 1); });
            state.groupStructure[groupIndex]--;
            renderGrid();
        }

        function handleDimensionInput() {
            let inputCell = parseInt(ui.settingCellInput.value);
            if (isNaN(inputCell) || inputCell < 1) inputCell = 1;
            if (inputCell > 10) inputCell = 10; 
            state.cellCount = inputCell;

            let inputCols = parseInt(ui.settingColInput.value);
            if (inputCols < 1) inputCols = 1; if (inputCols > MAX_SIZE) inputCols = MAX_SIZE;
            
            // Reverted Dimension Logic
            if (state.chartType === 'stackedBar') {
                const currentGroupCount = state.cols;
                if (inputCols > currentGroupCount) {
                    const addedCount = inputCols - currentGroupCount;
                    for(let k=0; k<addedCount; k++) {
                        state.groupStructure.push(2); // Default 2 bars per new group
                        state.data.forEach(row => { row.push("", ""); });
                    }
                } else if (inputCols < currentGroupCount) {
                    const removedCount = currentGroupCount - inputCols;
                    for(let k=0; k<removedCount; k++) {
                        const barsToRemove = state.groupStructure.pop();
                        state.data.forEach(row => { row.splice(-barsToRemove, barsToRemove); });
                    }
                }
                state.cols = inputCols;
                renderGrid(); 
            } else {
                let inputRows = parseInt(ui.settingMarkSelect.value);
                state.cols = inputCols;
                let targetDataCols = inputCols;
                if (state.chartType === 'line') {
                    targetDataCols = inputCols + 1;
                }
                updateGridSize(inputRows, targetDataCols);
            }
            updateSettingInputs();
        }

        function updateGridSize(newRows, newCols) {
            const currentRows = state.data.length;
            const currentCols = currentRows > 0 ? state.data[0].length : 0;
            const newData = [];
            for (let i = 0; i < newRows; i++) {
                const newRow = [];
                for (let j = 0; j < newCols; j++) {
                    if (i < currentRows && j < currentCols) {
                        newRow.push(state.data[i][j]);
                    } else {
                        newRow.push("");
                    }
                }
                newData.push(newRow);
            }
            state.data = newData;
            state.rows = newRows;
            renderGrid();
        }

        function addColumn() {
            if (state.cols >= MAX_SIZE) return;

            if(state.chartType === 'stackedBar') {
                state.cols++;
                state.groupStructure.push(2); 
                state.data.forEach(row => { row.push("", ""); });
                updateSettingInputs(); 
                renderGrid();
            } else {
                state.cols++;
                updateGridSize(state.rows, state.cols);
                updateSettingInputs();
            }
            setTimeout(() => { ui.gridScrollArea.scrollTo({ left: ui.gridScrollArea.scrollWidth, behavior: 'smooth' }); }, 50);
        }
        
        function addRow() {
            if (state.rows >= MAX_SIZE) return;
            state.rows++;
            
            const currentCols = state.data.length > 0 ? state.data[0].length : 
                                (state.chartType === 'stackedBar' ? getTotalStackedCols() : state.cols);
            state.data.push(new Array(currentCols).fill(""));

            if(state.chartType !== 'stackedBar') ui.settingMarkSelect.value = state.rows;

            updateSettingInputs(); 
            renderGrid();
            
            setTimeout(() => { ui.gridScrollArea.scrollTo({ top: ui.gridScrollArea.scrollHeight, behavior: 'smooth' }); }, 50);
        }

        function deleteColumn(colIndex) {
            if (state.cols <= 1) return;
            
            if (state.chartType === 'stackedBar') {
                const barsToRemove = state.groupStructure[colIndex];
                let startAt = 0;
                for(let i=0; i<colIndex; i++) startAt += state.groupStructure[i];
                state.data.forEach(row => row.splice(startAt, barsToRemove));
                state.groupStructure.splice(colIndex, 1);
                state.cols--;
            } else {
                state.data.forEach(row => row.splice(colIndex, 1));
                state.cols--;
            }
            updateSettingInputs(); renderGrid();
        }

        function deleteRow(rowIndex) {
            if (state.chartType === 'stackedBar' && rowIndex === 0) return;
            
            if (state.rows <= 1) return;
            state.data.splice(rowIndex, 1);
            state.rows--;
            updateSettingInputs(); renderGrid();
        }

        // ==========================================
        // OTHER LOGIC (Load/Save/Reset)
        // ==========================================

        function resetData() {
            if (state.chartType === 'stackedBar') {
                state.cols = 3;
                state.groupStructure = [2, 2, 2]; // Reverted default structure (2 bars per group)
                state.rows = 4; // All + 3 Stacks
                state.data = initData(4, 6); // All + 3 Stacks = 4 rows, 6 cols total
            } else if (state.chartType === 'line') {
                state.rows = 3; state.cols = 3; state.data = initData(3, 4);
            } else {
                state.rows = 3; state.cols = 3; state.data = initData(3, 3);
            }
            state.dataMode = 'raw'; 
            updateSettingInputs();
            renderGrid();
        }

        function updateSettingInputs() {
            ui.settingCellInput.value = state.cellCount;
            
            if (state.chartType === 'stackedBar') {
                 ui.labelColInput.textContent = "Group Count"; 
                 ui.settingColInput.value = state.cols; 
                 ui.containerMarkWrapper.classList.add('hidden');
            } else {
                 ui.labelColInput.textContent = "Graph Col";
                 ui.settingColInput.value = state.cols;
                 ui.containerMarkWrapper.classList.remove('hidden');
                 
                 if (state.rows > 5) {
                    if (!ui.settingMarkSelect.querySelector(`option[value="${state.rows}"]`)) {
                        const opt = document.createElement('option');
                        opt.value = state.rows; opt.text = state.rows; ui.settingMarkSelect.appendChild(opt);
                    }
                 }
                 ui.settingMarkSelect.value = state.rows;
            }
        }

        function handleCsvUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            state.csvFileName = file.name;
            updateCsvUi();
            const reader = new FileReader();
            reader.onload = function(e) { parseAndApplyCsv(e.target.result); };
            reader.readAsText(file);
        }

        function parseAndApplyCsv(csvText) {
            const lines = csvText.split(/\r?\n/).filter(r => r.trim() !== '');
            if (lines.length === 0) return;

            let maxCols = 0;
            const tempRows = lines.map(line => {
                const cells = line.split(',');
                if (cells.length > maxCols) maxCols = cells.length;
                return cells;
            });

            const normalizedData = tempRows.map(row => {
                while (row.length < maxCols) { row.push(""); }
                return row.map(cell => cell.trim());
            });

            state.data = normalizedData;
            state.rows = normalizedData.length;

            if (state.chartType === 'stackedBar') {
                const currentTotal = getTotalStackedCols();
                if (maxCols !== currentTotal) {
                    state.cols = 1; 
                    state.groupStructure = [maxCols];
                }
            } else {
                state.cols = maxCols;
            }

            state.dataMode = 'raw'; 
            updateSettingInputs(); renderGrid(); updateCsvUi(); ui.csvInput.value = '';
        }

        function toggleMode() {
             const textBtnClass = 'bg-transparent border-0 text-primary hover:text-primary-hover font-semibold text-xs cursor-pointer transition-colors min-w-[40px]';
             if (state.mode === 'edit') {
                state.mode = 'read';
                ui.editModeBtn.textContent = "Edit";
                ui.editModeBtn.className = textBtnClass;
                ui.settingColInput.disabled = true; 
                ui.settingCellInput.disabled = true;
                ui.settingMarkSelect.disabled = true;
                ui.settingYMin.disabled = true;
                ui.settingYMax.disabled = true;
             } else {
                state.mode = 'edit';
                ui.editModeBtn.textContent = "Save";
                ui.editModeBtn.className = textBtnClass;
                ui.settingColInput.disabled = false; 
                ui.settingCellInput.disabled = false;
                ui.settingMarkSelect.disabled = false;
                ui.settingYMin.disabled = false;
                ui.settingYMax.disabled = false;
             }
             renderGrid(); checkCtaValidation(); 
        }

        function checkCtaValidation() {
            if (state.mode !== 'read') { ui.mainCta.disabled = true; return; }
            let isAllFilled = true;
            let isRangeError = false;
            
            const totalVisualRows = state.data.length;
            const totalCols = state.data.length > 0 ? state.data[0].length : 0;

            for (let i = 0; i < totalVisualRows; i++) {
                for (let j = 0; j < totalCols; j++) {
                    const val = state.data[i][j];
                    if (!val || val.trim() === "") isAllFilled = false;
                    if (state.dataMode === 'percent' && val && val.trim() !== "") {
                        const num = Number(val);
                        if (!isNaN(num) && (num < 0 || num > 100)) isRangeError = true;
                    }
                }
            }
            const toast = ui.errorToast;
            if (isRangeError) {
                if (toast.classList.contains('hidden')) { toast.classList.remove('hidden'); setTimeout(() => toast.classList.remove('opacity-0', 'translate-y-2'), 10); }
            } else {
                if (!toast.classList.contains('hidden') && !toast.classList.contains('opacity-0')) { toast.classList.add('opacity-0', 'translate-y-2'); setTimeout(() => toast.classList.add('hidden'), 300); }
            }
            ui.mainCta.disabled = !(isAllFilled && !isRangeError);
        }

        function submitData() {
            let finalValues = state.data.map(row => 
                row.map(cell => {
                    const num = Number(cell);
                    return isNaN(num) ? 0 : num;
                })
            );
            
            let rawValues = finalValues;
            let drawingValues = finalValues;
            let markNumPayload = state.groupStructure; 
            
            if (state.chartType === 'stackedBar' || state.chartType === 'stacked') {
                if (finalValues.length > 1) {
                    drawingValues = finalValues.slice(1);
                }
                markNumPayload = state.groupStructure;
            } else {
                markNumPayload = state.rows; 
            }

            const msgType = state.uiMode === 'create' ? 'generate' : 'apply';
            
            parent.postMessage({ 
                pluginMessage: { 
                    type: msgType, 
                    payload: {
                        type: state.chartType,
                        mode: state.dataMode, 
                        values: drawingValues, 
                        rawValues: rawValues,
                        rows: (state.chartType === 'stackedBar' || state.chartType === 'stacked') ? (state.rows - 1) : state.rows,
                        cols: state.cols,
                        cellCount: state.cellCount,
                        yMin: Number(ui.settingYMin.value),
                        yMax: Number(ui.settingYMax.value),
                        markNum: markNumPayload 
                    }
                } 
            }, '*');
        }

        ui.editModeBtn.addEventListener('click', toggleMode);
        ui.csvInput.addEventListener('change', handleCsvUpload);
        ui.csvDeleteBtn.addEventListener('click', removeCsv);
        ui.mainCta.addEventListener('click', submitData);
        
        ui.settingColInput.addEventListener('input', handleDimensionInput);
        ui.settingCellInput.addEventListener('input', handleDimensionInput); 
        ui.settingMarkSelect.addEventListener('change', handleDimensionInput);
        
        ui.addColFixedBtn.addEventListener('click', addColumn);
        ui.addRowFixedBtn.addEventListener('click', addRow);
        ui.csvExportBtn.addEventListener('click', downloadCsv);
        ui.resetBtn.addEventListener('click', resetData);

        /* ==========================================
   [DEBUG] Export & D3 Logic
   ========================================== */

// 0. D3.js 로드 확인 (가장 먼저 실행)
if (typeof d3 === 'undefined') {
    console.error("🚨 [ERROR] D3.js 라이브러리가 로드되지 않았습니다. 인터넷 연결을 확인하거나 로컬 파일을 사용하세요.");
    alert("D3.js 로드 실패! 프리뷰가 작동하지 않을 수 있습니다.");
} else {
    console.log("✅ [SUCCESS] D3.js 로드 완료:", d3.version);
}

// 1. 탭 전환 기능
window.switchTab = function(tabName) {
    console.log(`👉 [UI] 탭 전환 요청: ${tabName}`);
    
    const tabData = document.getElementById('tab-data');
    const tabExport = document.getElementById('tab-export');
    const step1 = document.getElementById('step-1');
    const step2 = document.getElementById('step-2');
    const stepExport = document.getElementById('step-export');

    const activeClass = 'px-3 py-0.5 text-xs font-semibold rounded bg-white shadow-sm text-primary transition-all border-0 cursor-pointer';
    const inactiveClass = 'px-3 py-0.5 text-xs font-semibold rounded text-text-sub hover:text-text bg-transparent transition-all border-0 cursor-pointer';

    if (tabName === 'data') {
        tabData.className = activeClass;
        tabExport.className = inactiveClass;
        stepExport.classList.remove('active');
        
        if (state.currentStep === 1) step1.classList.add('active');
        else step2.classList.add('active');
        
        if (state.currentStep === 2) ui.mainCta.style.display = 'block';

    } else if (tabName === 'export') {
        tabData.className = inactiveClass;
        tabExport.className = activeClass;
        step1.classList.remove('active');
        step2.classList.remove('active');
        stepExport.classList.add('active'); // 화면 먼저 표시 (렌더링 사이즈 확보)

        ui.mainCta.style.display = 'none';

        // 스타일 추출 요청 전송
        console.log("📤 [UI] 'extract_style' 메시지 전송");
        parent.postMessage({ pluginMessage: { type: 'extract_style' } }, '*');
    }
};

// 2. 메시지 수신 핸들러 (디버깅 로그 추가)
const originalOnMessage = window.onmessage;
window.onmessage = (event) => {
    if (originalOnMessage) originalOnMessage(event);

    const msg = event.data.pluginMessage;
    if (!msg) return;

    if (msg.type === 'style_extracted') {
        console.log("📥 [UI] 'style_extracted' 메시지 수신:", msg.payload);
        
        const styleData = msg.payload;
        
        // 데이터 유효성 검사
        if (!styleData) {
            console.error("🚨 [UI] 스타일 데이터가 비어있습니다.");
            return;
        }

        // 렌더링 시작
        try {
            renderD3Preview(styleData);
            document.getElementById('d3-code-output').value = generateD3CodeString(styleData);
            console.log("✅ [UI] D3 프리뷰 렌더링 완료");
        } catch (error) {
            console.error("🚨 [UI] 렌더링 중 에러 발생:", error);
        }
    }
};

// 3. D3.js 프리뷰 렌더링 함수
// [UI.html] D3.js 프리뷰 렌더링 함수 (고도화)
function renderD3Preview(style) {
    const container = document.getElementById('d3-preview-container');
    if (!container) return;
    container.innerHTML = '';

    // 1. 데이터 생성 로직 (다중 시리즈 지원)
    // markNum이 배열(Stacked)인 경우 단순화를 위해 첫 번째 그룹 크기나 1로 취급
    let seriesCount = 1;
    if (Array.isArray(style.markNum)) {
        seriesCount = style.markNum.length > 0 ? style.markNum[0] : 1; 
    } else {
        seriesCount = Number(style.markNum) || 1;
    }

    const colCount = style.colCount || 5;
    
    // 데이터 구조: [{ col: 0, v0: 10, v1: 20 }, { col: 1, ... }]
    const data = Array.from({ length: colCount }, (_, i) => {
        const item = { col: i };
        for (let s = 0; s < seriesCount; s++) {
            item[`v${s}`] = Math.floor(Math.random() * 80) + 10; // 10~90 랜덤값
        }
        return item;
    });

    // 2. SVG 설정
    const width = container.clientWidth || 300;
    const height = container.clientHeight || 200;
    const margin = { top: 20, right: 20, bottom: 30, left: 40 };

    const svg = d3.select(container)
        .append('svg')
        .attr('width', width)
        .attr('height', height);

    // X축 스케일 (컬럼용)
    const x0 = d3.scaleBand()
        .domain(d3.range(colCount))
        .range([margin.left, width - margin.right])
        .padding(1 - (style.markRatio || 0.8));

    // Y축 스케일
    const y = d3.scaleLinear()
        .domain([0, 100])
        .nice()
        .range([height - margin.bottom, margin.top]);

    // 3. 차트 타입별 그리기
    const colors = style.colors && style.colors.length > 0 ? style.colors : ['#18A0FB', '#9CA3AF', '#FCD34D'];

    // === CASE A: LINE CHART ===
    if (style.chartType === 'line') {
        // 시리즈별로 Line 그리기
        for (let s = 0; s < seriesCount; s++) {
            const line = d3.line()
                .x((d) => x0(d.col) + x0.bandwidth() / 2) // 밴드 중앙에 점 찍기
                .y((d) => y(d[`v${s}`]))
                .curve(d3.curveMonotoneX); // 부드러운 곡선

            // Path 추가
            svg.append("path")
                .datum(data)
                .attr("fill", "none")
                .attr("stroke", colors[s % colors.length])
                .attr("stroke-width", 2)
                .attr("d", line);

            // 점(Circle) 추가
            svg.selectAll(`.dot-s${s}`)
                .data(data)
                .enter().append("circle")
                .attr("cx", (d) => x0(d.col) + x0.bandwidth() / 2)
                .attr("cy", (d) => y(d[`v${s}`]))
                .attr("r", 3)
                .attr("fill", "#fff")
                .attr("stroke", colors[s % colors.length])
                .attr("stroke-width", 2);
        }

    // === CASE B: BAR CHART (Grouped or Simple) ===
    } else {
        // Grouped Bar를 위한 서브 스케일 (x1)
        const x1 = d3.scaleBand()
            .domain(d3.range(seriesCount))
            .range([0, x0.bandwidth()])
            .padding(0.05);

        const group = svg.append("g")
            .selectAll("g")
            .data(data)
            .join("g")
            .attr("transform", d => `translate(${x0(d.col)},0)`);

        group.selectAll("rect")
            .data(d => Array.from({ length: seriesCount }, (_, i) => ({ key: i, value: d[`v${i}`] })))
            .join("rect")
            .attr("x", d => x1(d.key))
            .attr("y", d => y(d.value))
            .attr("width", x1.bandwidth())
            .attr("height", d => y(0) - y(d.value))
            .attr("fill", d => colors[d.key % colors.length])
            .attr("rx", 2);
    }

    // 4. 축 그리기 (공통)
    // Y Axis
    svg.append('g')
        .attr('transform', `translate(${margin.left},0)`)
        .call(d3.axisLeft(y).ticks(style.yCount || 4))
        .call(g => g.select(".domain").remove())
        .call(g => g.selectAll(".tick line").attr("stroke-opacity", 0.1));

    // X Axis
    svg.append('g')
        .attr('transform', `translate(0,${height - margin.bottom})`)
        .call(d3.axisBottom(x0).tickFormat(i => i + 1))
        .call(g => g.select(".domain").attr("stroke", "#E0E0E0"));
}

// 4. D3 코드 생성 (기존 유지)
function generateD3CodeString(style) {
    // ... 기존 코드와 동일 ...
    // (이 부분은 에러가 잘 안나므로 생략하거나 기존 코드 사용)
    const colorsJson = JSON.stringify(style.colors && style.colors.length > 0 ? style.colors : ['#18A0FB']);
    const paddingVal = (1 - (style.markRatio || 0.8)).toFixed(2);
    const yTicksVal = style.yCount || 4;
    return `// D3.js Config \nconst config = { colors: ${colorsJson}, padding: ${paddingVal}, yTicks: ${yTicksVal} };`;
}

// 5. 복사 기능 (기존 유지)
window.copyToClipboard = function() {
    const copyText = document.getElementById("d3-code-output");
    copyText.select();
    document.execCommand("copy");
    
    // 복사 완료 피드백
    const btn = document.querySelector('button[onclick="copyToClipboard()"]');
    const originalHTML = btn.innerHTML;
    btn.innerHTML = `<span class="text-primary font-bold">Copied!</span>`;
    setTimeout(() => {
        btn.innerHTML = originalHTML;
    }, 1500);
};
   
   </script>
</body>
</html>